<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [dnsh-commits] r7 - in trunk: . DotnetShell.Parser
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/dnsh-commits/2005-June/index.html" >
   <LINK REL="made" HREF="mailto:dnsh-commits%40lists.berlios.de?Subject=Re%3A%20%5Bdnsh-commits%5D%20r7%20-%20in%20trunk%3A%20.%20DotnetShell.Parser&In-Reply-To=%3C200506012037.j51Kb8PQ004811%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000002.html">
   <LINK REL="Next"  HREF="000003.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[dnsh-commits] r7 - in trunk: . DotnetShell.Parser</H1>
    <B>Michael Tindal at BerliOS</B> 
    <A HREF="mailto:dnsh-commits%40lists.berlios.de?Subject=Re%3A%20%5Bdnsh-commits%5D%20r7%20-%20in%20trunk%3A%20.%20DotnetShell.Parser&In-Reply-To=%3C200506012037.j51Kb8PQ004811%40sheep.berlios.de%3E"
       TITLE="[dnsh-commits] r7 - in trunk: . DotnetShell.Parser">urilith at sheep.berlios.de
       </A><BR>
    <I>Wed Jun  1 22:37:08 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000002.html">[dnsh-commits] r6 - trunk
</A></li>
        <LI>Next message: <A HREF="000003.html">[dnsh-commits] r8 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4">[ date ]</a>
              <a href="thread.html#4">[ thread ]</a>
              <a href="subject.html#4">[ subject ]</a>
              <a href="author.html#4">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: urilith
Date: 2005-06-01 22:37:07 +0200 (Wed, 01 Jun 2005)
New Revision: 7

Added:
   trunk/AUTHORS
   trunk/DotnetShell.Parser/dnsh.g
Removed:
   trunk/DotnetShell.Parser/dnsh-parser.jay
Modified:
   trunk/
   trunk/ChangeLog
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/dnsh-commits">r36 at dreamshadow</A>:  urilith | 2005-06-01 15:36:14 -0500
 Wed Jun 01, 2005 Michael Tindal (<A HREF="https://lists.berlios.de/mailman/listinfo/dnsh-commits">mtindal at paradoxpoint.com</A>) -0500
 A DotnetShell.Parser/dnsh.g
   * New Antlr parser.
 D DotnetShell.Parser/dnsh-parser.jay
   * Remove old Jay parser.
 A AUTHORS
   * New file listing the authors, mainly added to test commit mailing-list.
 



Property changes on: trunk
___________________________________________________________________
Name: svk:merge
   - b743595e-7af7-0310-b020-feacd67de632:/local/dnsh/trunk:35
   + b743595e-7af7-0310-b020-feacd67de632:/local/dnsh/trunk:36

Added: trunk/AUTHORS
===================================================================
--- trunk/AUTHORS	2005-06-01 20:36:58 UTC (rev 6)
+++ trunk/AUTHORS	2005-06-01 20:37:07 UTC (rev 7)
@@ -0,0 +1,2 @@
+Michael Tindal (<A HREF="https://lists.berlios.de/mailman/listinfo/dnsh-commits">urilith at gentoo.org</A>)
+Elfyn McBratley (<A HREF="https://lists.berlios.de/mailman/listinfo/dnsh-commits">beu at gentoo.org</A>)

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-06-01 20:36:58 UTC (rev 6)
+++ trunk/ChangeLog	2005-06-01 20:37:07 UTC (rev 7)
@@ -1,3 +1,11 @@
+Wed Jun 01, 2005 Michael Tindal (<A HREF="https://lists.berlios.de/mailman/listinfo/dnsh-commits">mtindal at paradoxpoint.com</A>) -0500
+A   DotnetShell.Parser/dnsh.g
+  * New Antlr parser.
+D   DotnetShell.Parser/dnsh-parser.jay
+  * Remove old Jay parser.
+A   AUTHORS
+  * New file listing the authors, mainly added to test commit mailing-list.
+
 Fri May 20, 2005 Michael Tindal (<A HREF="https://lists.berlios.de/mailman/listinfo/dnsh-commits">mtindal at paradoxpoint.com</A>) -0500
 A   svkchangelog
   * Tool to automatically create ChangeLog entries.

Deleted: trunk/DotnetShell.Parser/dnsh-parser.jay
===================================================================
--- trunk/DotnetShell.Parser/dnsh-parser.jay	2005-06-01 20:36:58 UTC (rev 6)
+++ trunk/DotnetShell.Parser/dnsh-parser.jay	2005-06-01 20:37:07 UTC (rev 7)
@@ -1,4895 +0,0 @@
-%{
-//
-// dnsh-parser.jay: The Parser for Dotnet Shell (dnsh) Scripts
-//
-// Authors: Michael Tindal
-//
-// Based on the cs-parser.jay file shipped with Mono's C# compiler (mcs).
-//
-// Licensed under the terms of the GNU GPL
-//
-// (C) 2001 Ximian, Inc (<A HREF="http://www.ximian.com">http://www.ximian.com</A>)
-// (C) 2004 Novell, Inc
-//
-// TODO:
-//   (1) Figure out why error productions dont work.  `type-declaration' is a
-//       great spot to put an `error' because you can reproduce it with this input:
-//	 &quot;public X { }&quot;
-//
-// Possible optimization:
-//   Run memory profiler with parsing only, and consider dropping 
-//   arraylists where not needed.   Some pieces can use linked lists.
-//
-using System.Text;
-using System.IO;
-using System;
-
-namespace DotnetShell.Parser
-{
-	using System.Collections;
-
-	/// &lt;summary&gt;
-	///    The dnsh Parser
-	/// &lt;/summary&gt;
-	public class DnshParser {
-		NamespaceEntry  current_namespace;
-		TypeContainer   current_container;
-		TypeContainer	current_class;
-	
-		IIteratorContainer iterator_container;
-
-		/// &lt;summary&gt;
-		///   Current block is used to add statements as we find
-		///   them.  
-		/// &lt;/summary&gt;
-		Block      current_block, top_current_block;
-
-		/// &lt;summary&gt;
-		///   This is used by the unary_expression code to resolve
-		///   a name against a parameter.  
-		/// &lt;/summary&gt;
-		Parameters current_local_parameters;
-
-		/// &lt;summary&gt;
-		///   Using during property parsing to describe the implicit
-		///   value parameter that is passed to the &quot;set&quot; and &quot;get&quot;accesor
-		///   methods (properties and indexers).
-		/// &lt;/summary&gt;
-		Expression implicit_value_parameter_type;
-		Parameters indexer_parameters;
-
-		/// &lt;summary&gt;
-		///   Used to determine if we are parsing the get/set pair
-		///   of an indexer or a property
-		/// &lt;/summmary&gt;
-		bool  parsing_indexer;
-
-		///
-		/// An out-of-band stack.
-		///
-		Stack oob_stack;
-
-		///
-		/// Switch stack.
-		///
-		Stack switch_stack;
-
-		static public int yacc_verbose_flag;
-
-		// Name of the file we are parsing
-		public string name;
-
-		///
-		/// The current file.
-		///
-		SourceFile file;
-
-		///
-		/// Temporary Xml documentation cache.
-		/// For enum types, we need one more temporary store.
-		///
-		string tmpComment;
-		string enumTypeComment;
-	       		
-		/// Current attribute target
-		string current_attr_target;
-		
-		/// assembly and module attribute definition is enabled
-		bool global_attrs_enabled = true;
-
-		bool has_get, has_set;
-
-%}
-
-%token EOF
-%token NONE   /* This token is never returned by our lexer */
-%token ERROR		// This is used not by the parser, but by the tokenizer.
-			// do not remove.
-
-/*
- *These are the Dnsh keywords
- */
-%token FIRST_KEYWORD
-%token ABSTRACT	
-%token AS
-%token ADD
-%token ASSEMBLY
-%token BASE	
-%token BOOL	
-%token BREAK	
-%token BYTE	
-%token CASE	
-%token CATCH	
-%token CHAR	
-%token CHECKED	
-%token CLASS	
-%token CONST	
-%token CONTINUE	
-%token DECIMAL	
-%token DEFAULT	
-%token DELEGATE	
-%token DO	
-%token DOUBLE	
-%token ELSE	
-%token ENUM	
-%token EVENT	
-%token EXPLICIT	
-%token EXTERN	
-%token FALSE	
-%token FINALLY	
-%token FIXED	
-%token FLOAT	
-%token FOR	
-%token FOREACH	
-%token GOTO	
-%token IF	
-%token IMPLICIT	
-%token IN	
-%token INT	
-%token INTERFACE
-%token INTERNAL	
-%token IS
-%token LOCK	
-%token LONG	
-%token NAMESPACE
-%token NEW	
-%token NULL	
-%token OBJECT
-%token OPERATOR	
-%token OUT	
-%token OVERRIDE	
-%token PARAMS	
-%token PRIVATE	
-%token PROTECTED
-%token PUBLIC	
-%token READONLY	
-%token REF	
-%token RETURN	
-%token REMOVE
-%token SBYTE	
-%token SEALED	
-%token SHORT	
-%token SIZEOF	
-%token STACKALLOC
-%token STATIC	
-%token STRING	
-%token STRUCT	
-%token SWITCH	
-%token THIS	
-%token THROW	
-%token TRUE	
-%token TRY	
-%token TYPEOF	
-%token UINT	
-%token ULONG	
-%token UNCHECKED
-%token UNSAFE	
-%token USHORT	
-%token USING	
-%token VIRTUAL	
-%token VOID	
-%token VOLATILE
-%token WHILE	
-%token ARGLIST
-%token PARTIAL
-%token YIELD
-%token EXTERNAL
-%token PREFIX
-%token GLOBAL
-%token LOCAL
-%token SOURCE
-%token MODULE
-%token OPTION
-%token EXPORT
-%token PROMPT
-%token ALIAS
-
-/* Dnsh keywords which are not really keywords */
-%token GET           &quot;get&quot;
-%token SET           &quot;set&quot;
-
-%left LAST_KEYWORD
-
-/* Dnsh single character operators/punctuation. */
-%token OPEN_BRACE    &quot;{&quot;
-%token CLOSE_BRACE   &quot;}&quot;
-%token OPEN_BRACKET  &quot;[&quot;
-%token CLOSE_BRACKET &quot;]&quot;
-%token OPEN_PARENS   &quot;(&quot;
-%token CLOSE_PARENS  &quot;)&quot;
-%token DOT           &quot;.&quot;
-%token COMMA         &quot;,&quot;
-%token COLON         &quot;:&quot;
-%token SEMICOLON     &quot;;&quot;
-%token TILDE         &quot;~&quot;
-
-%token PLUS           &quot;+&quot;
-%token MINUS          &quot;-&quot;
-%token BANG           &quot;!&quot;
-%token ASSIGN         &quot;=&quot;
-%token OP_LT          &quot;&lt;&quot;
-%token OP_GT          &quot;&gt;&quot;
-%token BITWISE_AND    &quot;&amp;&quot;
-%token BITWISE_OR     &quot;|&quot;
-%token STAR           &quot;*&quot;
-%token PERCENT        &quot;%&quot;
-%token DIV            &quot;/&quot;
-%token CARRET         &quot;^&quot;
-%token INTERR         &quot;?&quot;
-%token VARNORM	      &quot;$&quot;
-%token EXTCMD	      &quot;@&quot;
-
-/* Dnsh multi-character operators. */
-%token OP_INC                 &quot;++&quot;
-%token OP_DEC                 &quot;--&quot;
-%token OP_SHIFT_LEFT          &quot;&lt;&lt;&quot;
-%token OP_SHIFT_RIGHT         &quot;&gt;&gt;&quot;
-%token OP_LE                  &quot;&lt;=&quot;
-%token OP_GE                  &quot;&gt;=&quot;
-%token OP_EQ                  &quot;==&quot;
-%token OP_NE                  &quot;!=&quot;
-%token OP_AND                 &quot;&amp;&amp;&quot;
-%token OP_OR                  &quot;||&quot;
-%token OP_MULT_ASSIGN         &quot;*=&quot;
-%token OP_DIV_ASSIGN          &quot;/=&quot;
-%token OP_MOD_ASSIGN          &quot;%=&quot;
-%token OP_ADD_ASSIGN          &quot;+=&quot;
-%token OP_SUB_ASSIGN          &quot;-=&quot;
-%token OP_SHIFT_LEFT_ASSIGN   &quot;&lt;&lt;=&quot;
-%token OP_SHIFT_RIGHT_ASSIGN  &quot;&gt;&gt;=&quot;
-%token OP_AND_ASSIGN          &quot;&amp;=&quot;
-%token OP_XOR_ASSIGN          &quot;^=&quot;
-%token OP_OR_ASSIGN           &quot;|=&quot;
-%token OP_PTR                 &quot;-&gt;&quot;
-%token OP_VARBRACE	 		  &quot;${&quot;
-%token OP_DOUBLECOLON		  &quot;::&quot;
-
-
-/* Numbers */
-%token LITERAL_INTEGER           &quot;int literal&quot;
-%token LITERAL_FLOAT             &quot;float literal&quot;
-%token LITERAL_DOUBLE            &quot;double literal&quot;
-%token LITERAL_DECIMAL           &quot;decimal literal&quot;
-%token LITERAL_CHARACTER         &quot;character literal&quot;
-%token LITERAL_STRING            &quot;string literal&quot;
-
-%token IDENTIFIER
-%token CLOSE_PARENS_CAST
-%token CLOSE_PARENS_NO_CAST
-%token CLOSE_PARENS_OPEN_PARENS
-%token CLOSE_PARENS_MINUS
-
-/* Add precedence rules to solve dangling else s/r conflict */
-%nonassoc LOWPREC
-%nonassoc IF
-%nonassoc ELSE
-%right ASSIGN
-%left OP_OR
-%left OP_AND
-%left BITWISE_OR
-%left BITWISE_AND
-%left OP_SHIFT_LEFT OP_SHIFT_RIGHT
-%left PLUS MINUS
-%left STAR DIV PERCENT
-%right BANG CARRET UMINUS
-%nonassoc OP_INC OP_DEC
-%left OPEN_PARENS
-%left OPEN_BRACKET OPEN_BRACE
-%left DOT
-%left OP_DOUBLECOLON
-%nonassoc HIGHPREC
-
-%start compilation_unit
-%%
-
-compilation_unit
-        : outer_declarations opt_EOF
-        | outer_declarations global_attributes opt_EOF
-        | global_attributes opt_EOF
-	| opt_EOF /* allow empty files */
-        ;
-	
-opt_EOF
-	: /* empty */
-	{
-		Lexer.check_incorrect_doc_comment ();
-	}
-	| EOF
-	{
-		Lexer.check_incorrect_doc_comment ();
-	}
-	;
-
-outer_declarations
-        : outer_declaration
-        | outer_declarations outer_declaration
-        ;
- 
-outer_declaration
-        : using_directive
-		| module_directive
-        | profile_directive
-        | option_directive
-        | global_declaration
-        | namespace_member_declaration
-        ;
-  
-using_directives
-	: using_directive 
-	| using_directives using_directive
-	;
-
-using_directive
-	: using_alias_directive
-	{
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	}
-	| using_namespace_directive
-	{
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	}
-	;
-
-using_alias_directive
-	: USING IDENTIFIER ASSIGN 
-	  namespace_or_type_name SEMICOLON
-	  {
-		current_namespace.UsingAlias ((string) $2, (MemberName) $4, lexer.Location);
-	  }
-	| USING error {
-		CheckIdentifierToken (yyToken);
-	  }
-	;
-
-using_namespace_directive
-	: USING namespace_name SEMICOLON 
-	  {
-		current_namespace.Using ((MemberName) $2, lexer.Location);
-          }
-	;
-
-//
-// Strictly speaking, namespaces don't have attributes but
-// we parse global attributes along with namespace declarations and then
-// detach them
-// 
-namespace_declaration
-	: opt_attributes NAMESPACE namespace_or_type_name
-	{
-		if ($1 != null) {
-			Report.Error(1671, Lexer.Location, &quot;A namespace declaration cannot have modifiers or attributes&quot;);
-		}
-
-		MemberName name = (MemberName) $3;
-
-		current_namespace = new NamespaceEntry (
-			current_namespace, file, name.GetName (), lexer.Location);
-	  } 
-	  namespace_body opt_semicolon
-	  { 
-		current_namespace = current_namespace.Parent;
-	  }
-	;
-
-opt_semicolon
-	: /* empty */
-	| SEMICOLON
-	;
-
-opt_comma
-	: /* empty */
-	| COMMA
-	;
-
-namespace_name
-	: namespace_or_type_name
-	;
-
-namespace_body
-	: OPEN_BRACE
-	  {
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	  opt_using_directives
-	  opt_namespace_member_declarations
-	  CLOSE_BRACE
-	  {
-	  }
-	;
-
-opt_using_directives
-	: /* empty */
-	| using_directives
-	;
-
-opt_namespace_member_declarations
-	: /* empty */
-	| namespace_member_declarations
-	;
-
-namespace_member_declarations
-	: namespace_member_declaration
-	| namespace_member_declarations namespace_member_declaration
-	;
-
-namespace_member_declaration
-	: type_declaration
-	  {
-		if ($1 != null) {
-			DeclSpace ds = (DeclSpace)$1;
-
-			if ((ds.ModFlags &amp; (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
-				Report.Error (1527, lexer.Location, 
-				&quot;Namespace elements cannot be explicitly declared as private, protected or protected internal&quot;);
-			}
-		}
-		current_namespace.DeclarationFound = true;
-	  }
-	| namespace_declaration {
-		current_namespace.DeclarationFound = true;
-	  }
-
-	| field_declaration {
-		Report.Error (116, lexer.Location, &quot;A namespace can only contain types and namespace declarations&quot;);
-	  }
-	| method_declaration {
-		Report.Error (116, lexer.Location, &quot;A namespace can only contain types and namespace declarations&quot;);
-	  }
-	;
-
-type_declaration
-	: class_declaration		
-	| struct_declaration		
-	| interface_declaration		
-	| enum_declaration		
-	| delegate_declaration
-//
-// Enable this when we have handled all errors, because this acts as a generic fallback
-//
-//	| error {
-//		Console.WriteLine (&quot;Token=&quot; + yyToken);
-//		Report.Error (1518, lexer.Location, &quot;Expected class, struct, interface, enum or delegate&quot;);
-//	  }
-	;
-
-//
-// Attributes 17.2
-//
-
-global_attributes
-	: attribute_sections
-{
-	if ($1 != null)
-		CodeGen.Assembly.AddAttributes (((Attributes)$1).Attrs);
-
-	$$ = $1;
-}
-
-opt_attributes
-	: /* empty */ 
-	  {
-		global_attrs_enabled = false;
-		$$ = null;
-      }
-	| attribute_sections
-	  { 
-		global_attrs_enabled = false;
-		$$ = $1;
-	  }
-    ;
- 
-
-attribute_sections
-	: attribute_section
-	  {
-		ArrayList sect = (ArrayList) $1;
-
-		if (global_attrs_enabled) {
-			if (current_attr_target == &quot;module&quot;) {
-				CodeGen.Module.AddAttributes (sect);
-				$$ = null;
-			} else if (current_attr_target == &quot;assembly&quot;) {
-				CodeGen.Assembly.AddAttributes (sect);
-				$$ = null;
-			} else {
-				$$ = new Attributes (sect);
-			}
-			if ($$ == null) {
-				if (RootContext.Documentation != null) {
-					Lexer.check_incorrect_doc_comment ();
-					Lexer.doc_state =
-						XmlCommentState.Allowed;
-				}
-			}
-		} else {
-			$$ = new Attributes (sect);
-		}		
-		current_attr_target = null;
-	  }
-	| attribute_sections attribute_section
-	  {
-		Attributes attrs = $1 as Attributes;
-		ArrayList sect = (ArrayList) $2;
-
-		if (global_attrs_enabled) {
-			if (current_attr_target == &quot;module&quot;) {
-				CodeGen.Module.AddAttributes (sect);
-				$$ = null;
-			} else if (current_attr_target == &quot;assembly&quot;) {
-				CodeGen.Assembly.AddAttributes (sect);
-				$$ = null;
-			} else {
-				if (attrs == null)
-					attrs = new Attributes (sect);
-				else
-					attrs.AddAttributes (sect);			
-			}
-		} else {
-			if (attrs == null)
-				attrs = new Attributes (sect);
-			else
-				attrs.AddAttributes (sect);
-		}		
-		$$ = attrs;
-		current_attr_target = null;
-	  }
-	;
-
-attribute_section
-	: OPEN_BRACKET attribute_target_specifier attribute_list opt_comma CLOSE_BRACKET
-	  {
-		$$ = $3;
- 	  }
-        | OPEN_BRACKET attribute_list opt_comma CLOSE_BRACKET
-	  {
-		$$ = $2;
-	  }
-	;
- 
-attribute_target_specifier
-	: attribute_target COLON
-	  {
-		current_attr_target = (string)$1;
-		$$ = $1;
-	  }
-	;
-
-attribute_target
-	: IDENTIFIER
-	  {
-		CheckAttributeTarget ((string) $1);
-		$$ = $1;
-	  }
-        | EVENT  { $$ = &quot;event&quot;; }	  
-        | RETURN { $$ = &quot;return&quot;; }
-	;
-
-attribute_list
-	: attribute
-	  {
-		ArrayList attrs = new ArrayList (4);
-		attrs.Add ($1);
-
-		$$ = attrs;
-	       
-	  }
-	| attribute_list COMMA attribute
-	  {
-		ArrayList attrs = (ArrayList) $1;
-		attrs.Add ($3);
-
-		$$ = attrs;
-	  }
-	;
-
-attribute
-	: attribute_name
-	  {
-		$$ = lexer.Location;
-	  }
-	  opt_attribute_arguments
-	  {
-		  Location loc = (Location) $2;
-		MemberName mname = (MemberName) $1;
-		MemberName left = mname.Left;
-		string identifier = mname.Name;
-
-		Expression left_expr = left == null ? null : left.GetTypeExpression (loc);
-
-		if (current_attr_target == &quot;assembly&quot; || current_attr_target == &quot;module&quot;)
-			$$ = new GlobalAttribute (current_class, current_attr_target,
-						  left_expr, identifier, (ArrayList) $3, loc);
-		else
-			$$ = new Attribute (current_attr_target, left_expr, identifier, (ArrayList) $3, loc);
-	  }
-	;
-
-attribute_name
-	: namespace_or_type_name  { /* reserved attribute name or identifier: 17.4 */ }
-	;
-
-opt_attribute_arguments
-	: /* empty */   { $$ = null; }
-	| OPEN_PARENS attribute_arguments CLOSE_PARENS
-	  {
-		$$ = $2;
-	  }
-	;
-
-
-attribute_arguments
-	: opt_positional_argument_list
-	  {
-		if ($1 == null)
-			$$ = null;
-		else {
-			ArrayList args = new ArrayList (4);
-			args.Add ($1);
-		
-			$$ = args;
-		}
-	  }
-        | positional_argument_list COMMA named_argument_list
-	  {
-		ArrayList args = new ArrayList (4);
-		args.Add ($1);
-		args.Add ($3);
-
-		$$ = args;
-	  }
-        | named_argument_list
-	  {
-		ArrayList args = new ArrayList (4);
-		args.Add (null);
-		args.Add ($1);
-		
-		$$ = args;
-	  }
-        ;
-
-
-opt_positional_argument_list
-	: /* empty */ 		{ $$ = null; } 
-	| positional_argument_list
-	;
-
-positional_argument_list
-	: expression
-	  {
-		ArrayList args = new ArrayList (4);
-		args.Add (new Argument ((Expression) $1, Argument.AType.Expression));
-
-		$$ = args;
-	  }
-        | positional_argument_list COMMA expression
-	 {
-		ArrayList args = (ArrayList) $1;
-		args.Add (new Argument ((Expression) $3, Argument.AType.Expression));
-
-		$$ = args;
-	 }
-        ;
-
-named_argument_list
-	: named_argument
-	  {
-		ArrayList args = new ArrayList (4);
-		args.Add ($1);
-
-		$$ = args;
-	  }
-        | named_argument_list COMMA named_argument
-	  {	  
-		ArrayList args = (ArrayList) $1;
-		args.Add ($3);
-
-		$$ = args;
-	  }
-	  | named_argument_list COMMA expression
-	    {
-		  Report.Error (1016, lexer.Location, &quot;Named attribute argument expected&quot;);
-		  $$ = null;
-		}
-        ;
-
-named_argument
-	: IDENTIFIER ASSIGN expression
-	  {
-		$$ = new DictionaryEntry (
-			(string) $1, 
-			new Argument ((Expression) $3, Argument.AType.Expression));
-	  }
-	;
-
-		  
-class_body
-	:  OPEN_BRACE opt_class_member_declarations CLOSE_BRACE
-	;
-
-opt_class_member_declarations
-	: /* empty */
-	| class_member_declarations
-	;
-
-class_member_declarations
-	: class_member_declaration
-	| class_member_declarations 
-	  class_member_declaration
-	;
-
-class_member_declaration
-	: constant_declaration			// done
-	| field_declaration			// done
-	| method_declaration			// done
-	| property_declaration			// done
-	| event_declaration			// done
-	| indexer_declaration			// done
-	| operator_declaration			// done
-	| constructor_declaration		// done
-	| destructor_declaration		// done
-	| type_declaration
-	;
-
-struct_declaration
-	: opt_attributes
-	  opt_modifiers
-	  opt_partial
-	  STRUCT member_name
-	  { 
-		MemberName name = MakeName ((MemberName) $5);
-		bool partial = (bool) $3;
-
-		if (partial) {
-			ClassPart part = PartialContainer.CreatePart (
-				current_namespace, current_class, name, (int) $2,
-				(Attributes) $1, Kind.Struct, lexer.Location);
-
-			current_container = part.PartialContainer;
-			current_class = part;
-		} else {
-			current_class = new Struct (
-				current_namespace, current_class, name, (int) $2,
-				(Attributes) $1, lexer.Location);
-
-			current_container.AddClassOrStruct (current_class);
-			current_container = current_class;
-			RootContext.Tree.RecordDecl (name, current_class);
-		}
-	  }
-	  opt_class_base
-	  {
-		if ($7 != null)
-			current_class.Bases = (ArrayList) $7;
-
-		if (RootContext.Documentation != null)
-			current_class.DocComment = Lexer.consume_doc_comment ();
-	  }
-	  struct_body
-	  {
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	  opt_semicolon
-	  {
-		$$ = pop_current_class ();
-	  }
-	| opt_attributes opt_modifiers opt_partial STRUCT error {
-		CheckIdentifierToken (yyToken);
-	  }
-	;
-
-struct_body
-	: OPEN_BRACE
-	  {
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	  opt_struct_member_declarations CLOSE_BRACE
-	;
-
-opt_struct_member_declarations
-	: /* empty */
-	| struct_member_declarations
-	;
-
-struct_member_declarations
-	: struct_member_declaration
-	| struct_member_declarations struct_member_declaration
-	;
-
-struct_member_declaration
-	: constant_declaration
-	| field_declaration
-	| method_declaration
-	| property_declaration
-	| event_declaration
-	| indexer_declaration
-	| operator_declaration
-	| constructor_declaration
-	| type_declaration
-
-	/*
-	 * This is only included so we can flag error 575: 
-	 * destructors only allowed on class types
-	 */
-	| destructor_declaration 
-	;
-
-constant_declaration
-	: opt_attributes 
-	  opt_modifiers
-	  CONST
-	  type
-	  constant_declarators
-	  SEMICOLON
-	  {
-		int modflags = (int) $2;
-		foreach (VariableDeclaration constant in (ArrayList) $5){
-			Location l = constant.Location;
-			if ((modflags &amp; Modifiers.STATIC) != 0) {
-				Report.Error (504, l, &quot;The constant '{0}' cannot be marked static&quot;, current_container.GetSignatureForError () + '.' + (string) constant.identifier);
-				continue;
-			}
-
-			Const c = new Const (
-				current_class, (Expression) $4, (string) constant.identifier, 
-				(Expression) constant.expression_or_array_initializer, modflags, 
-				(Attributes) $1, l);
-
-			if (RootContext.Documentation != null) {
-				c.DocComment = Lexer.consume_doc_comment ();
-				Lexer.doc_state = XmlCommentState.Allowed;
-			}
-			current_container.AddConstant (c);
-		}
-	  }
-	;
-
-constant_declarators
-	: constant_declarator 
-	  {
-		ArrayList constants = new ArrayList (4);
-		if ($1 != null)
-			constants.Add ($1);
-		$$ = constants;
-	  }
-	| constant_declarators COMMA constant_declarator
-	  {
-		if ($3 != null) {
-			ArrayList constants = (ArrayList) $1;
-			constants.Add ($3);
-		}
-	  }
-	;
-
-constant_declarator
-	: IDENTIFIER ASSIGN constant_expression
-	  {
-		$$ = new VariableDeclaration ((string) $1, $3, lexer.Location);
-	  }
-	| IDENTIFIER
-	  {
-		// A const field requires a value to be provided
-		Report.Error (145, lexer.Location, &quot;A const field requires a value to be provided&quot;);
-		$$ = null;
-	  }
-	;
-
-field_declaration
-	: opt_attributes
-	  opt_modifiers
-	  type 
-	  variable_declarators
-	  SEMICOLON
-	  { 
-		Expression type = (Expression) $3;
-		int mod = (int) $2;
-
-		foreach (VariableDeclaration var in (ArrayList) $4){
-			Field field = new Field (current_class, type, mod, var.identifier, 
-						 var.expression_or_array_initializer, 
-						 (Attributes) $1, var.Location);
-
-			if (RootContext.Documentation != null) {
-				field.DocComment = Lexer.consume_doc_comment ();
-				Lexer.doc_state = XmlCommentState.Allowed;
-			}
-			current_container.AddField (field);
-		}
-	  }
-	| opt_attributes
-	  opt_modifiers
-	  FIXED
-	  type 
-	  fixed_variable_declarators
-	  SEMICOLON
-	  { 
-			Expression type = (Expression) $4;
-			int mod = (int) $2;
-
-			foreach (VariableDeclaration var in (ArrayList) $5) {
-				FixedField field = new FixedField (current_class, type, mod, var.identifier,
-					(Expression)var.expression_or_array_initializer, (Attributes) $1, var.Location);
-
-				if (RootContext.Documentation != null) {
-					field.DocComment = Lexer.consume_doc_comment ();
-					Lexer.doc_state = XmlCommentState.Allowed;
-				}
-				current_container.AddField (field);
-			}
-	  }
-	| opt_attributes
-	  opt_modifiers
-	  VOID  
-	  variable_declarators
-	  SEMICOLON {
-		Report.Error (670, lexer.Location, &quot;void type is not allowed for fields&quot;);
-	  }
-	;
-
-fixed_variable_declarators
-	: fixed_variable_declarator
-		{
-			ArrayList decl = new ArrayList (2);
-			decl.Add ($1);
-			$$ = decl;
-		}
-	| fixed_variable_declarators COMMA fixed_variable_declarator
-		{
-			ArrayList decls = (ArrayList) $1;
-			decls.Add ($3);
-			$$ = $1;
-		}
-	;
-
-fixed_variable_declarator
-	: IDENTIFIER OPEN_BRACKET expression CLOSE_BRACKET
-		{
-			$$ = new VariableDeclaration ((string) $1, $3, lexer.Location);
-		}
-	;
-
-variable_declarators
-	: variable_declarator 
-	  {
-		ArrayList decl = new ArrayList (4);
-		decl.Add ($1);
-		$$ = decl;
-	  }
-	| variable_declarators COMMA variable_declarator
-	  {
-		ArrayList decls = (ArrayList) $1;
-		decls.Add ($3);
-		$$ = $1;
-	  }
-	;
-
-variable_declarator
-	: IDENTIFIER ASSIGN variable_initializer
-	  {
-		$$ = new VariableDeclaration ((string) $1, $3, lexer.Location);
-	  }
-	| IDENTIFIER
-	  {
-		$$ = new VariableDeclaration ((string) $1, null, lexer.Location);
-	  }
-	| IDENTIFIER OPEN_BRACKET opt_expression CLOSE_BRACKET
-	  {
-		Report.Error (650, lexer.Location, &quot;Syntax error, bad array declarator. To declare a managed array the rank specifier precedes the variable's identifier. &quot; +
-			&quot;To declare a fixed buffer field, use the fixed keyword before the field type&quot;);
-	  }
-	;
-
-variable_initializer
-	: expression
-	  {
-		$$ = $1;
-	  }
-	| array_initializer
-	  {
-		$$ = $1;
-	  }
-	| STACKALLOC type OPEN_BRACKET expression CLOSE_BRACKET
-	  {
-		$$ = new StackAlloc ((Expression) $2, (Expression) $4, lexer.Location);
-	  }
-	| STACKALLOC type
-	  {
-		Report.Error (1575, lexer.Location, &quot;A stackalloc expression requires [] after type&quot;);
-                $$ = null;
-	  }
-	;
-
-method_declaration
-	: method_header {
-		iterator_container = (IIteratorContainer) $1;
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-	  }
-	  method_body
-	  {
-		Method method = (Method) $1;
-		Block b = (Block) $3;
-		const int extern_abstract = (Modifiers.EXTERN | Modifiers.ABSTRACT);
-
-		if (b == null){
-			if ((method.ModFlags &amp; extern_abstract) == 0){
-				Report.Error (
-					501, lexer.Location,  current_container.MakeName (method.Name) +
-				        &quot;must declare a body because it is not marked abstract or extern&quot;);
-			}
-		} else {
-			if ((method.ModFlags &amp; Modifiers.EXTERN) != 0){
-				Report.Error (
-					179, lexer.Location, current_container.MakeName (method.Name) +
-					&quot; is declared extern, but has a body&quot;);
-			}
-		}
-
-		method.Block = (ToplevelBlock) $3;
-		current_container.AddMethod (method);
-
-		current_local_parameters = null;
-		iterator_container = null;
-
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	;
-
-opt_error_modifier
-	: /* empty */
-	| modifiers 
-	  {
-		int m = (int) $1;
-		int i = 1;
-
-		while (m != 0){
-			if ((i &amp; m) != 0){
-				Report.Error (
-					1585, lexer.Location, &quot;Member modifier `&quot; + 
-					Modifiers.Name (i) + &quot;' must precede member type and name&quot;);
-			}
-			m &amp;= ~i;
-			i = i &lt;&lt; 1;
-		}
-	  }
-	;
-
-method_header
-	: opt_attributes
-	  opt_modifiers
-	  type namespace_or_type_name
-	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS 
-	  {
-		MemberName name = (MemberName) $4;
-
-		Method method = new Method (current_class, (Expression) $3, (int) $2,
-					    false, name,  (Parameters) $6, (Attributes) $1,
-					    lexer.Location);
-
-		current_local_parameters = (Parameters) $6;
-
-		if (RootContext.Documentation != null)
-			method.DocComment = Lexer.consume_doc_comment ();
-
-		$$ = method;
-	  }
-	| opt_attributes
-	  opt_modifiers
-	  VOID namespace_or_type_name
-	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS 
-	  {
-		MemberName name = (MemberName) $4;
-
-		Method method = new Method (current_class, TypeManager.system_void_expr,
-					    (int) $2, false, name, (Parameters) $6,
-					    (Attributes) $1, lexer.Location);
-
-		current_local_parameters = (Parameters) $6;
-
-		if (RootContext.Documentation != null)
-			method.DocComment = Lexer.consume_doc_comment ();
-
-		$$ = method;
-	  }
-	| opt_attributes
-	  opt_modifiers
-	  type 
-	  modifiers namespace_or_type_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
-	  {
-		Report.Error (1585, lexer.Location, 
-			String.Format (&quot;Modifier {0} should appear before type&quot;, 
-				Modifiers.Name ((int) $4)));
-		MemberName name = (MemberName) $4;
-
-		Method method = new Method (current_class, TypeManager.system_void_expr,
-					    0, false, name, (Parameters) $7, (Attributes) $1,
-					    lexer.Location);
-
-		current_local_parameters = (Parameters) $7;
-
-		if (RootContext.Documentation != null)
-			method.DocComment = Lexer.consume_doc_comment ();
-
-		$$ = method;
-	  }
-	;
-
-method_body
-	: block
-	| SEMICOLON		{ $$ = null; }
-	;
-
-opt_formal_parameter_list
-	: /* empty */			{ $$ = Parameters.EmptyReadOnlyParameters; }
-	| formal_parameter_list
-	;
-
-formal_parameter_list
-	: fixed_parameters		
-	  { 
-		ArrayList pars_list = (ArrayList) $1;
-
-		Parameter [] pars = new Parameter [pars_list.Count];
-		pars_list.CopyTo (pars);
-
-	  	$$ = new Parameters (pars, null, lexer.Location); 
-	  } 
-	| fixed_parameters COMMA parameter_array
-	  {
-		ArrayList pars_list = (ArrayList) $1;
-
-		Parameter [] pars = new Parameter [pars_list.Count];
-		pars_list.CopyTo (pars);
-
-		$$ = new Parameters (pars, (Parameter) $3, lexer.Location); 
-	  }
-	| fixed_parameters COMMA ARGLIST
-	  {
-		ArrayList pars_list = (ArrayList) $1;
-
-		Parameter [] pars = new Parameter [pars_list.Count];
-		pars_list.CopyTo (pars);
-
-		$$ = new Parameters (pars, true, lexer.Location);
-	  }
-	| parameter_array COMMA fixed_parameters
-	  {
-		Report.Error (231, lexer.Location, &quot;A params parameter must be the last parameter in a formal parameter list&quot;);
-		$$ = null;
-	  }
-	| ARGLIST COMMA fixed_parameters
-	  {
-		Report.Error (257, lexer.Location, &quot;An __arglist parameter must be the last parameter in a formal parameter list&quot;);
-		$$ = null;
-	  }
-	| parameter_array 
-	  {
-		$$ = new Parameters (null, (Parameter) $1, lexer.Location);
-	  }
-	| ARGLIST
-	  {
-		$$ = new Parameters (null, true, lexer.Location);
-	  }
-	;
-
-fixed_parameters
-	: fixed_parameter	
-	  {
-		ArrayList pars = new ArrayList (4);
-
-		pars.Add ($1);
-		$$ = pars;
-	  }
-	| fixed_parameters COMMA fixed_parameter
-	  {
-		ArrayList pars = (ArrayList) $1;
-
-		pars.Add ($3);
-		$$ = $1;
-	  }
-	;
-
-fixed_parameter
-	: opt_attributes
-	  opt_parameter_modifier
-	  type
-	  IDENTIFIER
-	  {
-		$$ = new Parameter ((Expression) $3, (string) $4, (Parameter.Modifier) $2, (Attributes) $1);
-	  }
-	| opt_attributes
-	  opt_parameter_modifier
-	  type
-	  {
-		Report.Error (1001, lexer.Location, &quot;Identifier expected&quot;);
-		$$ = null;
-	  }
-	| opt_attributes
-	  opt_parameter_modifier
-	  type
-	  error {
-		CheckIdentifierToken (yyToken);
-		$$ = null;
-	  }
-	| opt_attributes
-	  opt_parameter_modifier
-	  type
-	  IDENTIFIER
-	  ASSIGN
-	  constant_expression
-	   {
-		 Report.Error (241, lexer.Location, &quot;Default parameter specifiers are not permitted&quot;);
-		 $$ = null;
-	   }
-	;
-
-opt_parameter_modifier
-	: /* empty */		{ $$ = Parameter.Modifier.NONE; }
-	| parameter_modifier
-	;
-
-parameter_modifier
-	: REF			{ $$ = Parameter.Modifier.REF | Parameter.Modifier.ISBYREF; }
-	| OUT			{ $$ = Parameter.Modifier.OUT | Parameter.Modifier.ISBYREF; }
-	;
-
-parameter_array
-	: opt_attributes PARAMS type IDENTIFIER
-	  { 
-		$$ = new Parameter ((Expression) $3, (string) $4, Parameter.Modifier.PARAMS, (Attributes) $1);
-		note (&quot;type must be a single-dimension array type&quot;); 
-	  }
-	| opt_attributes PARAMS parameter_modifier type IDENTIFIER 
-	  {
-		Report.Error (1611, lexer.Location, &quot;The params parameter cannot be declared as ref or out&quot;);
-                $$ = null;
-	  }
-	| opt_attributes PARAMS type error {
-		CheckIdentifierToken (yyToken);
-		$$ = null;
-	  }
-	;
-
-property_declaration
-	: opt_attributes
-	  opt_modifiers
-	  type
-	  namespace_or_type_name
-	  {
-		if (RootContext.Documentation != null)
-			tmpComment = Lexer.consume_doc_comment ();
-	  }
-	  OPEN_BRACE 
-	  {
-		implicit_value_parameter_type = (Expression) $3;
-
-		lexer.PropertyParsing = true;
-
-		$$ = lexer.Location;
-
-		iterator_container = SimpleIteratorContainer.GetSimple ();
-	  }
-	  accessor_declarations 
-	  {
-		lexer.PropertyParsing = false;
-		has_get = has_set = false;
-	  }
-	  CLOSE_BRACE
-	  { 
-		if ($8 == null)
-			break;
-
-		Property prop;
-		Pair pair = (Pair) $8;
-		Accessor get_block = (Accessor) pair.First;
-		Accessor set_block = (Accessor) pair.Second;
-
-		Location loc = (Location) $7;
-		MemberName name = (MemberName) $4;
-
-		prop = new Property (current_class, (Expression) $3, (int) $2, false,
-				     name, (Attributes) $1, get_block, set_block, loc);
-		if (SimpleIteratorContainer.Simple.Yields)
-			prop.SetYields ();
-		
-		current_container.AddProperty (prop);
-		implicit_value_parameter_type = null;
-		iterator_container = null;
-
-		if (RootContext.Documentation != null)
-			prop.DocComment = ConsumeStoredComment ();
-
-	  }
-	;
-
-accessor_declarations
-	: get_accessor_declaration
-	 {
-		$$ = new Pair ($1, null);
-	 }
-	| get_accessor_declaration accessor_declarations
-	 { 
-		Pair pair = (Pair) $2;
-		pair.First = $1;
-		$$ = pair;
-	 }
-	| set_accessor_declaration
-	 {
-		$$ = new Pair (null, $1);
-	 }
-	| set_accessor_declaration accessor_declarations
-	 { 
-		Pair pair = (Pair) $2;
-		pair.Second = $1;
-		$$ = pair;
-	 }
-	| error
-	  {
-		Report.Error (1014, lexer.Location, &quot;A get or set accessor expected&quot;);
-		$$ = null;
-	  }
-	;
-
-get_accessor_declaration
-	: opt_attributes opt_modifiers GET
-	  {
-		// If this is not the case, then current_local_parameters has already
-		// been set in indexer_declaration
-		if (parsing_indexer == false)
-			current_local_parameters = null;
-		else 
-			current_local_parameters = indexer_parameters;
-		lexer.PropertyParsing = false;
-	  }
-          accessor_body
-	  {
-		if (has_get) {
-			Report.Error (1007, lexer.Location, &quot;Property accessor already defined&quot;);
-			break;
-		}
-		$$ = new Accessor ((ToplevelBlock) $5, (int) $2, (Attributes) $1, lexer.Location);
-		has_get = true;
-		current_local_parameters = null;
-		lexer.PropertyParsing = true;
-
-		if (RootContext.Documentation != null)
-			if (Lexer.doc_state == XmlCommentState.Error)
-				Lexer.doc_state = XmlCommentState.NotAllowed;
-	  }
-	;
-
-set_accessor_declaration
-	: opt_attributes opt_modifiers SET 
-	  {
-		Parameter [] args;
-		Parameter implicit_value_parameter = new Parameter (
-			implicit_value_parameter_type, &quot;value&quot;, 
-			Parameter.Modifier.NONE, null);
-
-		if (parsing_indexer == false) {
-			args  = new Parameter [1];
-			args [0] = implicit_value_parameter;
-			current_local_parameters = new Parameters (args, null, lexer.Location);
-		} else {
-			Parameter [] fpars = indexer_parameters.FixedParameters;
-
-			if (fpars != null){
-				int count = fpars.Length;
-
-				args = new Parameter [count + 1];
-				fpars.CopyTo (args, 0);
-				args [count] = implicit_value_parameter;
-			} else 
-				args = null;
-			current_local_parameters = new Parameters (
-				args, indexer_parameters.ArrayParameter, lexer.Location);
-		}
-		
-		lexer.PropertyParsing = false;
-	  }
-	  accessor_body
-	  {
-		if (has_set) {
-			Report.Error (1007, lexer.Location, &quot;Property accessor already defined&quot;);
-			break;
-		}
-		$$ = new Accessor ((ToplevelBlock) $5, (int) $2, (Attributes) $1, lexer.Location);
-		has_set = true;
-		current_local_parameters = null;
-		lexer.PropertyParsing = true;
-
-		if (RootContext.Documentation != null
-			&amp;&amp; Lexer.doc_state == XmlCommentState.Error)
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-	  }
-	;
-
-accessor_body
-	: block 
-	| SEMICOLON		{ $$ = null; }
-	;
-
-interface_declaration
-	: opt_attributes
-	  opt_modifiers
-	  opt_partial
-	  INTERFACE member_name
-	  {
-		MemberName name = MakeName ((MemberName) $5);
-		bool partial = (bool) $3;
-
-		if (partial) {
-			ClassPart part = PartialContainer.CreatePart (
-				current_namespace, current_class, name, (int) $2,
-				(Attributes) $1, Kind.Interface, lexer.Location);
-
-			current_container = part.PartialContainer;
-			current_class = part;
-		} else {
-			current_class = new Interface (
-				current_namespace, current_class, name, (int) $2,
-				(Attributes) $1, lexer.Location);
-
-			current_container.AddInterface (current_class);
-			current_container = current_class;
-			RootContext.Tree.RecordDecl (name, current_class);
-		}
-	  }
-	  opt_class_base
-	  {
-		current_class.Bases = (ArrayList) $7;
-
-		if (RootContext.Documentation != null) {
-			current_class.DocComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-	  }
-	  interface_body 
-	  {
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	  opt_semicolon 
-	  {
-		$$ = pop_current_class ();
-	  }
-	| opt_attributes opt_modifiers opt_partial INTERFACE error {
-		CheckIdentifierToken (yyToken);
-	  }
-	;
-
-interface_body
-	: OPEN_BRACE
-	  opt_interface_member_declarations
-	  CLOSE_BRACE
-	;
-
-opt_interface_member_declarations
-	: /* empty */
-	| interface_member_declarations
-	;
-
-interface_member_declarations
-	: interface_member_declaration
-	| interface_member_declarations interface_member_declaration
-	;
-
-interface_member_declaration
-	: interface_method_declaration		
-	  { 
-		if ($1 == null)
-			break;
-
-		Method m = (Method) $1;
-
-		if (m.IsExplicitImpl)
-		        Report.Error (541, lexer.Location, 
-				&quot;Explicit interface declaration can only be declared in a class or struct&quot;);
-
-		current_container.AddMethod (m);
-
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	| interface_property_declaration	
-	  { 
-		if ($1 == null)
-			break;
-
-		Property p = (Property) $1;
-
-		if (p.IsExplicitImpl)
-		        Report.Error (541, lexer.Location, 
-				&quot;Explicit interface declaration can only be declared in a class or struct&quot;);
-
-		current_container.AddProperty (p);
-
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-       }
-	| interface_event_declaration 
-          { 
-		if ($1 != null){
-			Event e = (Event) $1;
-
-			if (e.IsExplicitImpl)
-				Report.Error (541, lexer.Location, 
-				    &quot;Explicit interface declaration can only be declared in a class or struct&quot;);
-			
-			current_container.AddEvent (e);
-		}
-
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	| interface_indexer_declaration
-	  { 
-		if ($1 == null)
-			break;
-
-		Indexer i = (Indexer) $1;
-
-		if (i.IsExplicitImpl)
-			Report.Error (541, lexer.Location, 
-				&quot;Explicit interface declaration can only be declared in a class or struct&quot;);
-
-		current_container.AddIndexer (i);
-
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	| delegate_declaration
-	  {
-		Report.Error (524, lexer.Location, &quot;Interfaces can not declare delegates&quot;);
-	  }
-	| class_declaration
-	  {
-		Report.Error (524, lexer.Location, &quot;Interfaces can not declare classes&quot;);
-	  }
-	| struct_declaration
-	  {
-		Report.Error (524, lexer.Location, &quot;Interfaces can not declare structures&quot;);
-	  }
-	| enum_declaration 
-	  {
-		Report.Error (524, lexer.Location, &quot;Interfaces can not declare enumerations&quot;);
-	  }
-	| interface_declaration 
-	  {
-		Report.Error (524, lexer.Location, &quot;Interfaces can not declare interfaces&quot;);
-	  } 
-	| constant_declaration
-	  {
-		Report.Error (525, lexer.Location, &quot;Interfaces cannot contain constants&quot;);
-	  }
-	;
-
-opt_new
-	: opt_modifiers 
-	  {
-		int val = (int) $1;
-		val = Modifiers.Check (Modifiers.NEW | Modifiers.UNSAFE, val, 0, lexer.Location);
-		$$ = val;
-	  }
-	;
-
-interface_method_declaration
-	: opt_attributes opt_new type namespace_or_type_name
-	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
-	  SEMICOLON
-	  {
-		MemberName name = (MemberName) $4;
-
-		$$ = new Method (current_class, (Expression) $3, (int) $2, true,
-				 name, (Parameters) $6, (Attributes) $1, lexer.Location);
-		if (RootContext.Documentation != null)
-			((Method) $$).DocComment = Lexer.consume_doc_comment ();
-	  }
-	| opt_attributes opt_new type namespace_or_type_name
-	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS
-	  OPEN_BRACE opt_statement_list CLOSE_BRACE
-	  {
-		Report.Error (531, lexer.Location, &quot;'{0}': interface members cannot have a definition&quot;, $4);
-		$$ = null;
-	  }
-	;
-
-interface_property_declaration
-	: opt_attributes
-	  opt_new
-	  type IDENTIFIER 
-	  OPEN_BRACE 
-	  { lexer.PropertyParsing = true; }
-	  interface_accessors 
-	  { lexer.PropertyParsing = false; }
-	  CLOSE_BRACE
-	  {
-		if ($3 == TypeManager.system_void_expr) {
-			Report.Error (547, lexer.Location, &quot;'{0}': property cannot have void type&quot;, $4);
-			break;
-		}
-
-		if ($7 == null)
-			break;
-
-                InterfaceAccessorInfo pinfo = (InterfaceAccessorInfo) $7;
-
-		$$ = new Property (current_class, (Expression) $3, (int) $2, true,
-				   new MemberName ((string) $4), (Attributes) $1,
-				   pinfo.Get, pinfo.Set, lexer.Location);
-		if (RootContext.Documentation != null)
-			((Property) $$).DocComment = Lexer.consume_doc_comment ();
-	  }
-	| opt_attributes
-	  opt_new
-	  type error {
-		CheckIdentifierToken (yyToken);
-		$$ = null;
-	  }
-	;
-
-interface_accessors
-	: opt_attributes opt_modifiers GET SEMICOLON	
-	{ $$ = new InterfaceAccessorInfo (true, false, (Attributes) $1, null, (int) $2, 0, lexer.Location, lexer.Location); }
-	| opt_attributes opt_modifiers GET OPEN_BRACE
-	 {  
-		Report.Error (531, lexer.Location, &quot;'{0}': interface members cannot have a definition&quot;, &quot;.get&quot;);
-		$$ = null;
-	 }
-	| opt_attributes opt_modifiers SET SEMICOLON		
-	{ $$ = new InterfaceAccessorInfo (false, true, null, (Attributes) $1, 0, (int) $2, lexer.Location, lexer.Location); }
-	| opt_attributes opt_modifiers GET SEMICOLON opt_attributes opt_modifiers SET SEMICOLON 
-	  { $$ = new InterfaceAccessorInfo (true, true, (Attributes) $1, (Attributes) $5, (int) $2, (int) $6, lexer.Location, lexer.Location); }
-	| opt_attributes opt_modifiers SET SEMICOLON opt_attributes opt_modifiers GET SEMICOLON
-	  { $$ = new InterfaceAccessorInfo (true, true, (Attributes) $5, (Attributes) $1, (int) $6, (int) $2, lexer.Location, lexer.Location); }
-	|
-	  {
-		Report.Error (548, lexer.Location, &quot;'{0}' : property or indexer must have at least one accessor&quot;, &quot;&quot;);
-	  }
-	;
-
-interface_event_declaration
-	: opt_attributes opt_new EVENT type IDENTIFIER SEMICOLON
-	  {
-		$$ = new EventField (current_class, (Expression) $4, (int) $2, true,
-				     new MemberName ((string) $5), null,
-				     (Attributes) $1, lexer.Location);
-		if (RootContext.Documentation != null)
-			((EventField) $$).DocComment = Lexer.consume_doc_comment ();
-	  }
-	| opt_attributes opt_new EVENT type error {
-		CheckIdentifierToken (yyToken);
-		$$ = null;
-	  }
-	| opt_attributes opt_new EVENT type IDENTIFIER ASSIGN  {
-		Report.Error (68, lexer.Location, &quot;Event declarations on interfaces can not be initialized.&quot;);
-		$$ = null;
-	  }
-	| opt_attributes opt_new EVENT type IDENTIFIER OPEN_BRACE
-	{
-		lexer.EventParsing = true;
-	}
-	event_accessor_declarations
-	{
-		lexer.EventParsing = false;
-	}
-	CLOSE_BRACE {
-		Report.Error (69, lexer.Location, &quot;Event in interface cannot have add or remove accessors&quot;);
- 		$$ = null;
- 	  }
-	;
-
-interface_indexer_declaration 
-	: opt_attributes opt_new type THIS 
-	  OPEN_BRACKET formal_parameter_list CLOSE_BRACKET
-	  OPEN_BRACE 
-	  { lexer.PropertyParsing = true; }
-	  interface_accessors 
-	  { lexer.PropertyParsing = false; }
-	  CLOSE_BRACE
-	  {
-		if ($10 == null)
-			break;
-
-		InterfaceAccessorInfo info = (InterfaceAccessorInfo) $10;
-
-		$$ = new Indexer (current_class, (Expression) $3,
-				  new MemberName (TypeContainer.DefaultIndexerName),
-				  (int) $2, true, (Parameters) $6, (Attributes) $1,
-				  info.Get, info.Set, lexer.Location);
-		if (RootContext.Documentation != null)
-			((Indexer) $$).DocComment = ConsumeStoredComment ();
-	  }
-	;
-
-operator_declaration
-	: opt_attributes opt_modifiers operator_declarator 
-	  {
-		iterator_container = SimpleIteratorContainer.GetSimple ();
-	  }
-	  operator_body
-	  {
-		if ($3 == null)
-			break;
-
-		OperatorDeclaration decl = (OperatorDeclaration) $3;
-		
-		Parameter [] param_list = new Parameter [decl.arg2type != null ? 2 : 1];
-
-		param_list[0] = new Parameter (decl.arg1type, decl.arg1name, Parameter.Modifier.NONE, null);
-		if (decl.arg2type != null)
-			param_list[1] = new Parameter (decl.arg2type, decl.arg2name, Parameter.Modifier.NONE, null);
-
-		Operator op = new Operator (
-			current_class, decl.optype, decl.ret_type, (int) $2, 
-			new Parameters (param_list, null, decl.location),
-			(ToplevelBlock) $5, (Attributes) $1, decl.location);
-
-		if (RootContext.Documentation != null) {
-			op.DocComment = tmpComment;
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-
-		if (SimpleIteratorContainer.Simple.Yields)
-			op.SetYields ();
-
-		// Note again, checking is done in semantic analysis
-		current_container.AddOperator (op);
-
-		current_local_parameters = null;
-		iterator_container = null;
-	  }
-	;
-
-operator_body 
-	: block
-	| SEMICOLON { $$ = null; }
-	; 
-operator_declarator
-	: type OPERATOR overloadable_operator 
-	  OPEN_PARENS type IDENTIFIER CLOSE_PARENS
-	{
-		Operator.OpType op = (Operator.OpType) $3;
-		CheckUnaryOperator (op);
-
-		if (op == Operator.OpType.Addition)
-			op = Operator.OpType.UnaryPlus;
-
-		if (op == Operator.OpType.Subtraction)
-			op = Operator.OpType.UnaryNegation;
-
-		Parameter [] pars = new Parameter [1];
-		Expression type = (Expression) $5;
-
-		pars [0] = new Parameter (type, (string) $6, Parameter.Modifier.NONE, null);
-
-		current_local_parameters = new Parameters (pars, null, lexer.Location);
-
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-		}
-
-		$$ = new OperatorDeclaration (op, (Expression) $1, type, (string) $6,
-					      null, null, lexer.Location);
-	}
-	| type OPERATOR overloadable_operator
-	  OPEN_PARENS 
-		type IDENTIFIER COMMA
-	  	type IDENTIFIER 
-	  CLOSE_PARENS
-        {
-		CheckBinaryOperator ((Operator.OpType) $3);
-
-		Parameter [] pars = new Parameter [2];
-
-		Expression typeL = (Expression) $5;
-		Expression typeR = (Expression) $8;
-
-	       pars [0] = new Parameter (typeL, (string) $6, Parameter.Modifier.NONE, null);
-	       pars [1] = new Parameter (typeR, (string) $9, Parameter.Modifier.NONE, null);
-
-	       current_local_parameters = new Parameters (pars, null, lexer.Location);
-
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-		}
-	       
-	       $$ = new OperatorDeclaration ((Operator.OpType) $3, (Expression) $1, 
-					     typeL, (string) $6,
-					     typeR, (string) $9, lexer.Location);
-        }
-	| conversion_operator_declarator
-	| type OPERATOR overloadable_operator
-	  OPEN_PARENS 
-		type IDENTIFIER COMMA
-	  	type IDENTIFIER COMMA
-		type IDENTIFIER
-	  CLOSE_PARENS
-	{
-		Report.Error (1534, lexer.Location, &quot;Overloaded binary operator '{0}' takes two parameters&quot;, $3);
-		$$ = null;
-	}
-
-	;
-
-overloadable_operator
-// Unary operators:
-	: BANG   { $$ = Operator.OpType.LogicalNot; }
-        | TILDE  { $$ = Operator.OpType.OnesComplement; }  
-        | OP_INC { $$ = Operator.OpType.Increment; }
-        | OP_DEC { $$ = Operator.OpType.Decrement; }
-        | TRUE   { $$ = Operator.OpType.True; }
-        | FALSE  { $$ = Operator.OpType.False; }
-// Unary and binary:
-        | PLUS { $$ = Operator.OpType.Addition; }
-        | MINUS { $$ = Operator.OpType.Subtraction; }
-// Binary:
-        | STAR { $$ = Operator.OpType.Multiply; }
-        | DIV {  $$ = Operator.OpType.Division; }
-        | PERCENT { $$ = Operator.OpType.Modulus; }
-        | BITWISE_AND { $$ = Operator.OpType.BitwiseAnd; }
-        | BITWISE_OR { $$ = Operator.OpType.BitwiseOr; }
-        | CARRET { $$ = Operator.OpType.ExclusiveOr; }
-        | OP_SHIFT_LEFT { $$ = Operator.OpType.LeftShift; }
-        | OP_SHIFT_RIGHT { $$ = Operator.OpType.RightShift; }
-        | OP_EQ { $$ = Operator.OpType.Equality; }
-        | OP_NE { $$ = Operator.OpType.Inequality; }
-        | OP_GT { $$ = Operator.OpType.GreaterThan; }
-        | OP_LT { $$ = Operator.OpType.LessThan; }
-        | OP_GE { $$ = Operator.OpType.GreaterThanOrEqual; }
-        | OP_LE { $$ = Operator.OpType.LessThanOrEqual; }
-	;
-
-conversion_operator_declarator
-	: IMPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS
-	  {
-		Parameter [] pars = new Parameter [1];
-
-		pars [0] = new Parameter ((Expression) $5, (string) $6, Parameter.Modifier.NONE, null);
-
-		current_local_parameters = new Parameters (pars, null, lexer.Location);  
-		  
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-		}
-
-		$$ = new OperatorDeclaration (Operator.OpType.Implicit, (Expression) $3, (Expression) $5, (string) $6,
-					      null, null, lexer.Location);
-	  }
-	| EXPLICIT OPERATOR type OPEN_PARENS type IDENTIFIER CLOSE_PARENS
-	  {
-		Parameter [] pars = new Parameter [1];
-
-		pars [0] = new Parameter ((Expression) $5, (string) $6, Parameter.Modifier.NONE, null);
-
-		current_local_parameters = new Parameters (pars, null, lexer.Location);  
-		  
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-		}
-
-		$$ = new OperatorDeclaration (Operator.OpType.Explicit, (Expression) $3, (Expression) $5, (string) $6,
-					      null, null, lexer.Location);
-	  }
-	| IMPLICIT error 
-	  {
-		syntax_error (lexer.Location, &quot;'operator' expected&quot;);
-	  }
-	| EXPLICIT error 
-	  {
-		syntax_error (lexer.Location, &quot;'operator' expected&quot;);
-	  }
-	;
-
-constructor_declaration
-	: opt_attributes
-	  opt_modifiers
-	  constructor_declarator
-	  constructor_body
-	  { 
-		Constructor c = (Constructor) $3;
-		c.Block = (ToplevelBlock) $4;
-		c.OptAttributes = (Attributes) $1;
-		c.ModFlags = (int) $2;
-	
-		if (RootContext.Documentation != null)
-			c.DocComment = ConsumeStoredComment ();
-
-		if (c.Name == current_container.Basename){
-			if ((c.ModFlags &amp; Modifiers.STATIC) != 0){
-				if ((c.ModFlags &amp; Modifiers.Accessibility) != 0){
-					Report.Error (
-						515, c.Location, String.Format (
-						&quot;`{0}.{1}': static constructor can not have access modifiers&quot;,
-						c.Name, current_container.Name));
-				}
-	
-				c.ModFlags = Modifiers.Check (Constructor.AllowedModifiers, (int) $2, Modifiers.PRIVATE, c.Location);	
-	
-				if (c.Initializer != null){
-					Report.Error (
-						514, c.Location, 
-						&quot;Static constructors can not have an explicit this or base &quot; +
-						&quot;constructor invocations&quot;);
-				}
-	
-				if (!c.Parameters.Empty){
-					Report.Error (
-						132, c.Location, &quot;Static constructors should not have parameters&quot;);
-				}
-			} else {
-				c.ModFlags = Modifiers.Check (Constructor.AllowedModifiers, (int) $2, Modifiers.PRIVATE, c.Location);
-			}
-		} else {
-			// We let another layer check the validity of the constructor.
-			//Console.WriteLine (&quot;{0} and {1}&quot;, c.Name, current_container.Basename);
-		}
-
-		current_container.AddConstructor (c);
-
-		current_local_parameters = null;
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	;
-
-constructor_declarator
-	: IDENTIFIER
-	  {
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-	  }
-	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS _mark_
-	  {
-		current_local_parameters = (Parameters) $4;
-	  }
-	  opt_constructor_initializer
-	  {
-		$$ = new Constructor (current_class, (string) $1, 0, (Parameters) $4,
-				      (ConstructorInitializer) $8, (Location) $6);
-	  }
-	;
-
-constructor_body
-	: block
-	| SEMICOLON 		{ $$ = null; }
-	;
-
-opt_constructor_initializer
-	: /* empty */			{ $$ = null; }
-	| constructor_initializer
-	;
-
-constructor_initializer
-	: COLON BASE OPEN_PARENS opt_argument_list CLOSE_PARENS
-	  {
-		$$ = new ConstructorBaseInitializer ((ArrayList) $4, current_local_parameters, lexer.Location);
-	  }
-	| COLON THIS OPEN_PARENS opt_argument_list CLOSE_PARENS
-	  {
-		$$ = new ConstructorThisInitializer ((ArrayList) $4, current_local_parameters, lexer.Location);
-	  }
-	| COLON error {
-		Report.Error (1018, lexer.Location, &quot;Keyword this or base expected&quot;);
-		$$ = null;
-	  }
-	;
-
-opt_finalizer
-        : /* EMPTY */           { $$ = 0; }
-        | UNSAFE		{ $$ = Modifiers.UNSAFE; }
-	| EXTERN		{ $$ = Modifiers.EXTERN; }
-        ;
-        
-destructor_declaration
-	: opt_attributes opt_finalizer TILDE 
-	  {
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-		}
-	  }
-	  IDENTIFIER OPEN_PARENS CLOSE_PARENS block
-	  {
-		if ((string) $5 != current_container.Basename){
-			Report.Error (574, lexer.Location, &quot;Name of destructor must match name of class&quot;);
-		} else if (current_container.Kind != Kind.Class){
-			Report.Error (575, lexer.Location, &quot;Destructors are only allowed in class types&quot;);
-		} else {
-			Location l = lexer.Location;
-
-			int m = (int) $2;
-			if (!RootContext.StdLib &amp;&amp; current_container.Name == &quot;System.Object&quot;)
-				m |= Modifiers.PROTECTED | Modifiers.VIRTUAL;
-			else
-				m |= Modifiers.PROTECTED | Modifiers.OVERRIDE;
-                        
-                        if ((m &amp; Modifiers.UNSAFE) != 0){
-                                if (!RootContext.Unsafe){
-                                        Report.Error (227, l,
-					      &quot;Unsafe code requires the -unsafe command &quot; +
-					      &quot;line option to be specified&quot;);
-                                }
-                        }
-                        
-			Method d = new Destructor (
-				current_class, TypeManager.system_void_expr, m, &quot;Finalize&quot;, 
-				new Parameters (null, null, l), (Attributes) $1, l);
-			if (RootContext.Documentation != null)
-				d.DocComment = ConsumeStoredComment ();
-		  
-			d.Block = (ToplevelBlock) $8;
-			current_container.AddMethod (d);
-		}
-	  }
-	;
-
-event_declaration
-	: opt_attributes
-	  opt_modifiers
-	  EVENT type variable_declarators SEMICOLON
-	  {
-		foreach (VariableDeclaration var in (ArrayList) $5) {
-
-			MemberName name = new MemberName (var.identifier);
-
-			Event e = new EventField (
-				current_class, (Expression) $4, (int) $2, false, name,
-				var.expression_or_array_initializer, (Attributes) $1,
-				lexer.Location);
-
-			current_container.AddEvent (e);
-
-			if (RootContext.Documentation != null) {
-				e.DocComment = Lexer.consume_doc_comment ();
-				Lexer.doc_state = XmlCommentState.Allowed;
-			}
-		}
-	  }
-	| opt_attributes
-	  opt_modifiers
-	  EVENT type namespace_or_type_name
-	  OPEN_BRACE _mark_
-	  {
-		implicit_value_parameter_type = (Expression) $4;  
-		lexer.EventParsing = true;
-	  }
-	  event_accessor_declarations
-	  {
-		lexer.EventParsing = false;  
-	  }
-	  CLOSE_BRACE
-	  {
-		Location loc = (Location) $7;
-
-		if ($9 == null){
-			Report.Error (65, lexer.Location, &quot;Event must have both add and remove accesors&quot;);
-			$$ = null;
-		} else {
-			Pair pair = (Pair) $9;
-			
-			MemberName name = (MemberName) $5;
-
-			Event e = new EventProperty (
-				current_class, (Expression) $4, (int) $2, false, name, null,
-				(Attributes) $1, (Accessor) pair.First, (Accessor) pair.Second,
-				loc);
-			if (RootContext.Documentation != null) {
-				e.DocComment = Lexer.consume_doc_comment ();
-				Lexer.doc_state = XmlCommentState.Allowed;
-			}
-
-			current_container.AddEvent (e);
-			implicit_value_parameter_type = null;
-		}
-	  }
-	| opt_attributes opt_modifiers EVENT type namespace_or_type_name OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS block {
-		MemberName mn = (MemberName) $5;
-
-		if (mn.Left != null)
-			Report.Error (71, lexer.Location, &quot;Explicit implementation of events requires property syntax&quot;);
-		else 
-			Report.Error (71, lexer.Location, &quot;Event declaration should use property syntax&quot;);
-
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	;
-
-event_accessor_declarations
-	: add_accessor_declaration remove_accessor_declaration
-	{
-		$$ = new Pair ($1, $2);
-	}
-	| remove_accessor_declaration add_accessor_declaration
-	{
-		$$ = new Pair ($2, $1);
-	}	
-	| add_accessor_declaration  { $$ = null; } 
-	| remove_accessor_declaration { $$ = null; } 
-	| error
-	{ 
-		Report.Error (1055, lexer.Location, &quot;An add or remove accessor expected&quot;);
-		$$ = null;
-	}
-	| { $$ = null; }
-	;
-
-add_accessor_declaration
-	: opt_attributes ADD
-	  {
-		Parameter [] args = new Parameter [1];
-		Parameter implicit_value_parameter = new Parameter (
-			implicit_value_parameter_type, &quot;value&quot;, 
-			Parameter.Modifier.NONE, null);
-
-		args [0] = implicit_value_parameter;
-		
-		current_local_parameters = new Parameters (args, null, lexer.Location);  
-		lexer.EventParsing = false;
-	  }
-          block
-	  {
-		$$ = new Accessor ((ToplevelBlock) $4, 0, (Attributes) $1, lexer.Location);
-		lexer.EventParsing = true;
-	  }
-	| opt_attributes ADD error {
-		Report.Error (73, lexer.Location, &quot;Add or remove accessor must have a body&quot;);
-		$$ = null;
-	  }
-	| opt_attributes modifiers ADD {
-		Report.Error (1609, lexer.Location, &quot;Modifiers cannot be placed on event accessor declarations&quot;);
-		$$ = null;
-	  }
-	;
-
-remove_accessor_declaration
-	: opt_attributes REMOVE
-	  {
-		Parameter [] args = new Parameter [1];
-		Parameter implicit_value_parameter = new Parameter (
-			implicit_value_parameter_type, &quot;value&quot;, 
-			Parameter.Modifier.NONE, null);
-
-		args [0] = implicit_value_parameter;
-		
-		current_local_parameters = new Parameters (args, null, lexer.Location);  
-		lexer.EventParsing = false;
-	  }
-          block
-	  {
-		$$ = new Accessor ((ToplevelBlock) $4, 0, (Attributes) $1, lexer.Location);
-		lexer.EventParsing = true;
-	  }
-	| opt_attributes REMOVE error {
-		Report.Error (73, lexer.Location, &quot;Add or remove accessor must have a body&quot;);
-		$$ = null;
-	  }
-	| opt_attributes modifiers REMOVE {
-		Report.Error (1609, lexer.Location, &quot;Modifiers cannot be placed on event accessor declarations&quot;);
-		$$ = null;
-	  }
-	;
-
-indexer_declaration
-	: opt_attributes opt_modifiers indexer_declarator 
-	  OPEN_BRACE _mark_
-	  {
-		IndexerDeclaration decl = (IndexerDeclaration) $3;
-
-		implicit_value_parameter_type = decl.type;
-		
-		lexer.PropertyParsing = true;
-		parsing_indexer  = true;
-		
-		indexer_parameters = decl.param_list;
-	  }
-          accessor_declarations 
-	  {
-		  lexer.PropertyParsing = false;
-		  has_get = has_set = false;
-		  parsing_indexer  = false;
-	  }
-	  CLOSE_BRACE
-	  { 
-		if ($7 == null)
-			break;
-
-		// The signature is computed from the signature of the indexer.  Look
-	 	// at section 3.6 on the spec
-		Location loc = (Location) $5;
-		Indexer indexer;
-		IndexerDeclaration decl = (IndexerDeclaration) $3;
-		Pair pair = (Pair) $7;
-		Accessor get_block = (Accessor) pair.First;
-		Accessor set_block = (Accessor) pair.Second;
-
-		MemberName name;
-		if (decl.interface_type != null)
-			name = new MemberName (decl.interface_type,
-					       TypeContainer.DefaultIndexerName);
-		else
-			name = new MemberName (TypeContainer.DefaultIndexerName);
-
-		indexer = new Indexer (current_class, decl.type, name,
-				       (int) $2, false, decl.param_list, (Attributes) $1,
-				       get_block, set_block, loc);
-		if (RootContext.Documentation != null)
-			indexer.DocComment = ConsumeStoredComment ();
-
-		current_container.AddIndexer (indexer);
-		
-		current_local_parameters = null;
-		implicit_value_parameter_type = null;
-		indexer_parameters = null;
-	  }
-	;
-
-indexer_declarator
-	: type THIS OPEN_BRACKET opt_formal_parameter_list CLOSE_BRACKET
-	  {
-		Parameters pars = (Parameters) $4;
-		if (pars.HasArglist) {
-			// &quot;__arglist is not valid in this context&quot;
-			Report.Error (1669, lexer.Location, &quot;__arglist is not valid in this context&quot;);
-		} else if (pars.FixedParameters == null &amp;&amp; pars.ArrayParameter == null){
-			Report.Error (1551, lexer.Location, &quot;Indexers must have at least one parameter&quot;);
-		}
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-
-		$$ = new IndexerDeclaration ((Expression) $1, null, pars);
-	  }
-	| type namespace_or_type_name DOT THIS OPEN_BRACKET opt_formal_parameter_list CLOSE_BRACKET
-	  {
-		Parameters pars = (Parameters) $6;
-
-		if (pars.HasArglist) {
-			// &quot;__arglist is not valid in this context&quot;
-			Report.Error (1669, lexer.Location, &quot;__arglist is not valid in this context&quot;);
-		} else if (pars.FixedParameters == null &amp;&amp; pars.ArrayParameter == null){
-			Report.Error (1551, lexer.Location, &quot;Indexers must have at least one parameter&quot;);
-		}
-
-		MemberName name = (MemberName) $2;
-		$$ = new IndexerDeclaration ((Expression) $1, name, pars);
-
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-	  }
-	;
-
-enum_declaration
-	: opt_attributes
-	  opt_modifiers
-	  opt_partial
-	  ENUM IDENTIFIER 
-	  opt_enum_base {
-		if (RootContext.Documentation != null)
-			enumTypeComment = Lexer.consume_doc_comment ();
-	  }
-	  enum_body
-	  opt_semicolon
-	  {
-		bool partial = (bool) $3;
-
-		if (partial) {
-			Report.Error (267, lexer.Location, &quot;The partial modifier can only appear before a 'class', 'struct', or 'interface'&quot;);
-			break;	// assumes that the parser put us in a switch
-		}
-
-		Location enum_location = lexer.Location;
-
-		MemberName name = MakeName (new MemberName ((string) $5));
-		Enum e = new Enum (current_namespace, current_class, (Expression) $6, (int) $2,
-				   name, (Attributes) $1, enum_location);
-		
-		if (RootContext.Documentation != null)
-			e.DocComment = enumTypeComment;
-
-		foreach (VariableDeclaration ev in (ArrayList) $8) {
-			e.AddEnumMember (ev.identifier, 
-					 (Expression) ev.expression_or_array_initializer,
-					 ev.Location, ev.OptAttributes,
-					 ev.DocComment);
-		}
-
-		current_container.AddEnum (e);
-		RootContext.Tree.RecordDecl (name, e);
-		$$ = e;
-
-	  }
-	;
-
-opt_enum_base
-	: /* empty */		{ $$ = TypeManager.system_int32_expr; }
-	| COLON type		{ $$ = $2;   }
-	;
-
-enum_body
-	: OPEN_BRACE
-	  {
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	  opt_enum_member_declarations
-	  {
-	  	// here will be evaluated after CLOSE_BLACE is consumed.
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	  CLOSE_BRACE
-	  {
-		$$ = $3;
-	  }
-	;
-
-opt_enum_member_declarations
-	: /* empty */			{ $$ = new ArrayList (4); }
-	| enum_member_declarations opt_comma { $$ = $1; }
-	;
-
-enum_member_declarations
-	: enum_member_declaration 
-	  {
-		ArrayList l = new ArrayList (4);
-
-		l.Add ($1);
-		$$ = l;
-	  }
-	| enum_member_declarations COMMA enum_member_declaration
-	  {
-		ArrayList l = (ArrayList) $1;
-
-		l.Add ($3);
-
-		$$ = l;
-	  }
-	;
-
-enum_member_declaration
-	: opt_attributes IDENTIFIER 
-	  {
-		VariableDeclaration vd = new VariableDeclaration ((string) $2, null, lexer.Location, (Attributes) $1);
-
-		if (RootContext.Documentation != null) {
-			vd.DocComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-
-		$$ = vd;
-	  }
-	| opt_attributes IDENTIFIER
-	  {
-		$$ = lexer.Location;
-		if (RootContext.Documentation != null) {
-			tmpComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.NotAllowed;
-		}
-	  }
-          ASSIGN expression
-	  { 
-		VariableDeclaration vd = new VariableDeclaration ((string) $2, $5, lexer.Location, (Attributes) $1);
-
-		if (RootContext.Documentation != null)
-			vd.DocComment = ConsumeStoredComment ();
-
-		$$ = vd;
-	  }
-	;
-
-delegate_declaration
-	: opt_attributes
-	  opt_modifiers
-	  DELEGATE type member_name
-	  OPEN_PARENS opt_formal_parameter_list CLOSE_PARENS 
-	  SEMICOLON
-	  {
-		Location l = lexer.Location;
-		MemberName name = MakeName ((MemberName) $5);
-		Delegate del = new Delegate (current_namespace, current_class, (Expression) $4,
-					     (int) $2, name, (Parameters) $7, (Attributes) $1, l);
-
-		if (RootContext.Documentation != null) {
-			del.DocComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-
-		current_container.AddDelegate (del);
-		RootContext.Tree.RecordDecl (name, del);
-		$$ = del;
-	  }	
-	;
-
-namespace_or_type_name
-	: member_name
-	| namespace_or_type_name DOT IDENTIFIER {
-		$$ = new MemberName ((MemberName) $1, (string) $3);
-	  }
-	;
-
-member_name
-	: IDENTIFIER {
-		$$ = new MemberName ((string) $1);
-	  }
-	;
-
-/* 
- * Before you think of adding a return_type, notice that we have been
- * using two rules in the places where it matters (one rule using type
- * and another identical one that uses VOID as the return type).  This
- * gets rid of a shift/reduce couple
- */
-type
-	: namespace_or_type_name
-	  {
-		$$ = ((MemberName) $1).GetTypeExpression (lexer.Location);
-	  }
-	| builtin_types
-	| array_type
-	| pointer_type	  
-	;
-
-
-pointer_type
-	: type STAR
-	  {
-		//
-		// Note that here only unmanaged types are allowed but we
-		// can't perform checks during this phase - we do it during
-		// semantic analysis.
-		//
-		$$ = new ComposedCast ((Expression) $1, &quot;*&quot;, lexer.Location);
-	  }
-	| VOID STAR
-	  {
-		$$ = new ComposedCast (TypeManager.system_void_expr, &quot;*&quot;, lexer.Location);
-	  }
-	;
-
-non_expression_type
-	: builtin_types	
-	| non_expression_type rank_specifier
-	  {
-		$$ = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
-	  }
-	| non_expression_type STAR
-	  {
-		$$ = new ComposedCast ((Expression) $1, &quot;*&quot;, lexer.Location);
-	  }
-	| expression rank_specifiers 
-	  {
-		$$ = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
-	  }
-	| expression STAR 
-	  {
-		$$ = new ComposedCast ((Expression) $1, &quot;*&quot;, lexer.Location);
-	  }
-	
-	//
-	// We need this because the parser will happily go and reduce IDENTIFIER STAR
-	// through this different path
-	//
-	| multiplicative_expression STAR 
-	  {
-		$$ = new ComposedCast ((Expression) $1, &quot;*&quot;, lexer.Location);
-	  }
-	;
-
-type_list
-	: type
-	  {
-		ArrayList types = new ArrayList (4);
-
-		types.Add ($1);
-		$$ = types;
-	  }
-	| type_list COMMA type
-	  {
-		ArrayList types = (ArrayList) $1;
-
-		types.Add ($3);
-		$$ = types;
-	  }
-	;
-
-/*
- * replaces all the productions for isolating the various
- * simple types, but we need this to reuse it easily in local_variable_type
- */
-builtin_types
-	: OBJECT	{ $$ = TypeManager.system_object_expr; }
-	| STRING	{ $$ = TypeManager.system_string_expr; }
-	| BOOL		{ $$ = TypeManager.system_boolean_expr; }
-	| DECIMAL	{ $$ = TypeManager.system_decimal_expr; }
-	| FLOAT		{ $$ = TypeManager.system_single_expr; }
-	| DOUBLE	{ $$ = TypeManager.system_double_expr; }
-	| integral_type
-	;
-
-integral_type
-	: SBYTE		{ $$ = TypeManager.system_sbyte_expr; }
-	| BYTE		{ $$ = TypeManager.system_byte_expr; }
-	| SHORT		{ $$ = TypeManager.system_int16_expr; }
-	| USHORT	{ $$ = TypeManager.system_uint16_expr; }
-	| INT		{ $$ = TypeManager.system_int32_expr; }
-	| UINT		{ $$ = TypeManager.system_uint32_expr; }
-	| LONG		{ $$ = TypeManager.system_int64_expr; }
-	| ULONG		{ $$ = TypeManager.system_uint64_expr; }
-	| CHAR		{ $$ = TypeManager.system_char_expr; }
-	| VOID		{ $$ = TypeManager.system_void_expr; }
-	;
-
-array_type
-	: type rank_specifiers
-	  {
-		$$ = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
-	  }
-	;
-
-//
-// Expressions, section 7.5
-//
-primary_expression
-	: literal
-	  {
-		// 7.5.1: Literals
-	  }
- 
-	| member_name
-	  {
-		$$ = ((MemberName) $1).GetTypeExpression (lexer.Location);
-	  }
-	| parenthesized_expression
-	| member_access
-	| invocation_expression
-	| element_access
-	| this_access
-	| base_access
-	| post_increment_expression
-	| post_decrement_expression
-	| new_expression
-	| typeof_expression
-	| sizeof_expression
-	| checked_expression
-	| unchecked_expression
-	| pointer_member_access
-	| anonymous_method_expression
-	;
-
-literal
-	: boolean_literal
-	| integer_literal
-	| real_literal
-	| LITERAL_CHARACTER     { $$ = new CharLiteral ((char) lexer.Value); }
-	| LITERAL_STRING        { $$ = new StringLiteral ((string) lexer.Value); }
-	| NULL			{ $$ = NullLiteral.Null; }
-	;
-
-real_literal
-	: LITERAL_FLOAT         { $$ = new FloatLiteral ((float) lexer.Value); }
-	| LITERAL_DOUBLE        { $$ = new DoubleLiteral ((double) lexer.Value); }
-	| LITERAL_DECIMAL       { $$ = new DecimalLiteral ((decimal) lexer.Value); }
-	;
-
-integer_literal
-	: LITERAL_INTEGER       { 
-		object v = lexer.Value;
-
-		if (v is int){
-			int i = (int) v;
-
-			if (i == 0)
-				$$ = IntLiteral.Zero;
-			else if (i == 1)
-				$$ = IntLiteral.One;
-			else
-				$$ = new IntLiteral (i);
-		} else if (v is uint)
-			$$ = new UIntLiteral ((UInt32) v);
-		else if (v is long)
-			$$ = new LongLiteral ((Int64) v);
-		else if (v is ulong)
-			$$ = new ULongLiteral ((UInt64) v);
-		else
-			Console.WriteLine (&quot;OOPS.  Unexpected result from scanner&quot;);
-	  }
-	;
-
-boolean_literal
-	: TRUE			{ $$ = new BoolLiteral (true); }
-	| FALSE			{ $$ = new BoolLiteral (false); }
-	;
-
-parenthesized_expression_0
-	: OPEN_PARENS expression CLOSE_PARENS
-	  {
-		$$ = $2;
-		lexer.Deambiguate_CloseParens ();
-		// After this, the next token returned is one of
-		// CLOSE_PARENS_CAST, CLOSE_PARENS_NO_CAST, CLOSE_PARENS_OPEN_PARENS
-		// or CLOSE_PARENS_MINUS.
-	  }
-	;
-
-parenthesized_expression
-	: parenthesized_expression_0 CLOSE_PARENS_NO_CAST
-	  {
-		$$ = $1;
-	  }
-	| parenthesized_expression_0 CLOSE_PARENS_MINUS
-	  {
-		// If a parenthesized expression is followed by a minus, we need to wrap
-		// the expression inside a ParenthesizedExpression for the CS0075 check
-		// in Binary.DoResolve().
-		$$ = new ParenthesizedExpression ((Expression) $1, lexer.Location);
-	  }
-	;;
-
-member_access
-	: primary_expression DOT IDENTIFIER
-	  {
-		$$ = new MemberAccess ((Expression) $1, (string) $3, lexer.Location);
-	  }
-	| predefined_type DOT IDENTIFIER
-	  {
-		$$ = new MemberAccess ((Expression) $1, (string) $3, lexer.Location);
-	  }
-	;
-
-predefined_type
-	: builtin_types
-	;
-
-invocation_expression
-	: primary_expression OPEN_PARENS opt_argument_list CLOSE_PARENS
-	  {
-		if ($1 == null) {
-			Location l = lexer.Location;
-			Report.Error (1, l, &quot;Parse error&quot;);
-		}
-		$$ = new Invocation ((Expression) $1, (ArrayList) $3, lexer.Location);
-	  }
-	| parenthesized_expression_0 CLOSE_PARENS_OPEN_PARENS OPEN_PARENS CLOSE_PARENS
-	  {
-		$$ = new Invocation ((Expression) $1, new ArrayList (), lexer.Location);
-	  }
-	| parenthesized_expression_0 CLOSE_PARENS_OPEN_PARENS primary_expression
-	  {
-		$$ = new InvocationOrCast ((Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| parenthesized_expression_0 CLOSE_PARENS_OPEN_PARENS OPEN_PARENS non_simple_argument CLOSE_PARENS
-	  {
-		ArrayList args = new ArrayList (1);
-		args.Add ($4);
-		$$ = new Invocation ((Expression) $1, args, lexer.Location);
-	  }
-	| parenthesized_expression_0 CLOSE_PARENS_OPEN_PARENS OPEN_PARENS argument_list COMMA argument CLOSE_PARENS
-	  {
-		ArrayList args = ((ArrayList) $4);
-		args.Add ($6);
-		$$ = new Invocation ((Expression) $1, args, lexer.Location);
-	  }
-	;
-
-opt_argument_list
-	: /* empty */		{ $$ = null; }
-	| argument_list
-	;
-
-argument_list
-	: argument
-	  { 
-		ArrayList list = new ArrayList (4);
-		list.Add ($1);
-		$$ = list;
-	  }
-	| argument_list COMMA argument
-	  {
-		ArrayList list = (ArrayList) $1;
-		list.Add ($3);
-		$$ = list;
-	  }
-	| argument_list error {
-		CheckToken (1026, yyToken, &quot;, or ) expected&quot;);
-	  }
-	;
-
-argument
-	: expression
-	  {
-		$$ = new Argument ((Expression) $1, Argument.AType.Expression);
-	  }
-	| non_simple_argument
-	  {
-		$$ = $1;
-	  }
-	;
-
-non_simple_argument
-	: REF variable_reference 
-	  { 
-		$$ = new Argument ((Expression) $2, Argument.AType.Ref);
-	  }
-	| OUT variable_reference 
-	  { 
-		$$ = new Argument ((Expression) $2, Argument.AType.Out);
-	  }
-	| ARGLIST OPEN_PARENS argument_list CLOSE_PARENS
-	  {
-		ArrayList list = (ArrayList) $3;
-		Argument[] args = new Argument [list.Count];
-		list.CopyTo (args, 0);
-
-		Expression expr = new Arglist (args, lexer.Location);
-		$$ = new Argument (expr, Argument.AType.Expression);
-	  }
-	| ARGLIST
-	  {
-		$$ = new Argument (new ArglistAccess (lexer.Location), Argument.AType.ArgList);
-	  }
-	;
-
-variable_reference
-	: expression { note (&quot;section 5.4&quot;); $$ = $1; }
-	;
-
-element_access
-	: primary_expression OPEN_BRACKET expression_list CLOSE_BRACKET	
-	  {
-		$$ = new ElementAccess ((Expression) $1, (ArrayList) $3, lexer.Location);
-	  }
-	| primary_expression rank_specifiers
-	  {
-		// So the super-trick is that primary_expression
-		// can only be either a SimpleName or a MemberAccess. 
-		// The MemberAccess case arises when you have a fully qualified type-name like :
-		// Foo.Bar.Blah i;
-		// SimpleName is when you have
-		// Blah i;
-		  
-		Expression expr = (Expression) $1;  
-		if (expr is ComposedCast){
-			$$ = new ComposedCast (expr, (string) $2, lexer.Location);
-		} else if (!(expr is SimpleName || expr is MemberAccess)){
-			Error_ExpectingTypeName (lexer.Location, expr);
-			$$ = TypeManager.system_object_expr;
-		} else {
-			//
-			// So we extract the string corresponding to the SimpleName
-			// or MemberAccess
-			// 
-			$$ = new ComposedCast (expr, (string) $2, lexer.Location);
-		}
-	  }
-	;
-
-expression_list
-	: expression
-	  {
-		ArrayList list = new ArrayList (4);
-		list.Add ($1);
-		$$ = list;
-	  }
-	| expression_list COMMA expression
-	  {
-		ArrayList list = (ArrayList) $1;
-		list.Add ($3);
-		$$ = list;
-	  }
-	;
-
-this_access
-	: THIS
-	  {
-		$$ = new This (current_block, lexer.Location);
-	  }
-	;
-
-base_access
-	: BASE DOT IDENTIFIER
-	  {
-		$$ = new BaseAccess ((string) $3, lexer.Location);
-	  }
-	| BASE OPEN_BRACKET expression_list CLOSE_BRACKET
-	  {
-		$$ = new BaseIndexerAccess ((ArrayList) $3, lexer.Location);
-	  }
-	| BASE error {
-		Report.Error (175, lexer.Location, &quot;Use of keyword `base' is not valid in this context&quot;);
-		$$ = null;
-	  }
-	;
-
-post_increment_expression
-	: primary_expression OP_INC
-	  {
-		$$ = new UnaryMutator (UnaryMutator.Mode.PostIncrement,
-				       (Expression) $1, lexer.Location);
-	  }
-	;
-
-post_decrement_expression
-	: primary_expression OP_DEC
-	  {
-		$$ = new UnaryMutator (UnaryMutator.Mode.PostDecrement,
-				       (Expression) $1, lexer.Location);
-	  }
-	;
-
-new_expression
-	: object_or_delegate_creation_expression
-	| array_creation_expression
-	;
-
-object_or_delegate_creation_expression
-	: NEW type OPEN_PARENS opt_argument_list CLOSE_PARENS
-	  {
-		$$ = new New ((Expression) $2, (ArrayList) $4, lexer.Location);
-	  }
-	;
-
-array_creation_expression
-	: NEW type OPEN_BRACKET expression_list CLOSE_BRACKET 
-	  opt_rank_specifier
-	  opt_array_initializer
-	  {
-		$$ = new ArrayCreation ((Expression) $2, (ArrayList) $4, (string) $6, (ArrayList) $7, lexer.Location);
-	  }
-	| NEW type rank_specifiers array_initializer
-	  {
-		$$ = new ArrayCreation ((Expression) $2, (string) $3, (ArrayList) $4, lexer.Location);
-	  }
-	| NEW error
-	  {
-		Report.Error (1031, lexer.Location, &quot;Type expected&quot;);
-                $$ = null;
-	  }          
-	| NEW type error 
-	  {
-		Report.Error (1526, lexer.Location, &quot;new expression requires () or [] after type&quot;);
-	  }
-	;
-
-opt_rank_specifier
-	: /* empty */
-	  {
-		  $$ = &quot;&quot;;
-	  }
-	| rank_specifiers
-	  {
-			$$ = $1;
-	  }
-	;
-
-rank_specifiers
-	: rank_specifier opt_rank_specifier
-	  {
-		  $$ = (string) $2 + (string) $1;
-	  }
-        ;
-
-rank_specifier
-	: OPEN_BRACKET opt_dim_separators CLOSE_BRACKET
-	  {
-		$$ = &quot;[&quot; + (string) $2 + &quot;]&quot;;
-	  }
-	;
-
-opt_dim_separators
-	: /* empty */
-	  {
-		$$ = &quot;&quot;;
-	  }
-	| dim_separators
-	  {
-		  $$ = $1;
-	  }		  
-	;
-
-dim_separators
-	: COMMA
-	  {
-		$$ = &quot;,&quot;;
-	  }
-	| dim_separators COMMA
-	  {
-		$$ = (string) $1 + &quot;,&quot;;
-	  }
-	;
-
-opt_array_initializer
-	: /* empty */
-	  {
-		$$ = null;
-	  }
-        | array_initializer
-	  {
-		$$ = $1;
-	  }
-	;
-
-array_initializer
-	: OPEN_BRACE CLOSE_BRACE
-	  {
-		ArrayList list = new ArrayList (4);
-		$$ = list;
-	  }
-	| OPEN_BRACE variable_initializer_list opt_comma CLOSE_BRACE
-	  {
-		$$ = (ArrayList) $2;
-	  }
-	;
-
-variable_initializer_list
-	: variable_initializer
-	  {
-		ArrayList list = new ArrayList (4);
-		list.Add ($1);
-		$$ = list;
-	  }
-	| variable_initializer_list COMMA variable_initializer
-	  {
-		ArrayList list = (ArrayList) $1;
-		list.Add ($3);
-		$$ = list;
-	  }
-	;
-
-typeof_expression
-	: TYPEOF OPEN_PARENS VOID CLOSE_PARENS
-	  {
-		$$ = new TypeOfVoid (lexer.Location);
-	  }
-	| TYPEOF OPEN_PARENS type CLOSE_PARENS
-	  {
-		$$ = new TypeOf ((Expression) $3, lexer.Location);
-	  }
-	;
-
-sizeof_expression
-	: SIZEOF OPEN_PARENS type CLOSE_PARENS { 
-		$$ = new SizeOf ((Expression) $3, lexer.Location);
-	  }
-	;
-
-checked_expression
-	: CHECKED OPEN_PARENS expression CLOSE_PARENS
-	  {
-		$$ = new CheckedExpr ((Expression) $3, lexer.Location);
-	  }
-	;
-
-unchecked_expression
-	: UNCHECKED OPEN_PARENS expression CLOSE_PARENS
-	  {
-		$$ = new UnCheckedExpr ((Expression) $3, lexer.Location);
-	  }
-	;
-
-pointer_member_access 
-	: primary_expression OP_PTR IDENTIFIER
-	  {
-		Expression deref;
-
-		deref = new Unary (Unary.Operator.Indirection, (Expression) $1, lexer.Location);
-		$$ = new MemberAccess (deref, (string) $3, lexer.Location);
-	  }
-	;
-
-anonymous_method_expression
-	: DELEGATE opt_anonymous_method_signature _mark_
-	  {
-		oob_stack.Push (current_local_parameters);
-		current_local_parameters = (Parameters)$2;
-
-		// Force the next block to be created as a ToplevelBlock
-		oob_stack.Push (current_block);
-		oob_stack.Push (top_current_block);
-		current_block = null;
-	  } 
-	  block
-	  {
-		Location loc = (Location) $3;
-		top_current_block = (Block) oob_stack.Pop ();
-		current_block = (Block) oob_stack.Pop ();
-		if (RootContext.Version == LanguageVersion.ISO_1){
-			Report.FeatureIsNotStandardized (lexer.Location, &quot;anonymous methods&quot;);
-			$$ = null;
-		} else  {
-			ToplevelBlock anon_block = (ToplevelBlock) $5;
-
-			anon_block.Parent = current_block;
-			$$ = new AnonymousMethod ((Parameters) $2, (ToplevelBlock) top_current_block, 
-				anon_block, loc);
-		}
-		current_local_parameters = (Parameters) oob_stack.Pop ();
-	  }
-	;
-
-opt_anonymous_method_signature
-	: /* empty */			{ $$ = null; } 
-	| anonymous_method_signature
-	;
-
-anonymous_method_signature
-	: OPEN_PARENS opt_anonymous_method_parameter_list CLOSE_PARENS 
-	  {
-		if ($2 == null)
-			$$ = Parameters.EmptyReadOnlyParameters;
-		else {
-			ArrayList par_list = (ArrayList) $2;
-			Parameter [] pars = new Parameter [par_list.Count];
-			par_list.CopyTo (pars);
-			$$ = new Parameters (pars, null, lexer.Location);
-		}
-	  }
-	;
-
-opt_anonymous_method_parameter_list
-	: /* empty */	                   { $$ = null; } 
-	| anonymous_method_parameter_list  { $$ = $1; }
-	;
-
-anonymous_method_parameter_list
-	: anonymous_method_parameter 
-	  {
-		ArrayList a = new ArrayList (4);
-		a.Add ($1);
-		$$ = a;
-	  }
-	| anonymous_method_parameter_list COMMA anonymous_method_parameter 
-	  {
-		ArrayList a = (ArrayList) $1;
-		a.Add ($3);
-		$$ = a;
-	  }
-	; 
-
-anonymous_method_parameter
-	: opt_parameter_modifier type IDENTIFIER {
-		$$ = new Parameter ((Expression) $2, (string) $3, (Parameter.Modifier) $1, null);
-	  }
-	| PARAMS type IDENTIFIER {
-		Report.Error (1670, lexer.Location, &quot;params modifier not allowed in anonymous method declaration&quot;);
-		$$ = null;
-	  }
-	;
-
-unary_expression
-	: primary_expression
-	| BANG prefixed_unary_expression
-	  {
-		$$ = new Unary (Unary.Operator.LogicalNot, (Expression) $2, lexer.Location);
-	  }
-	| TILDE prefixed_unary_expression
-	  {
-		$$ = new Unary (Unary.Operator.OnesComplement, (Expression) $2, lexer.Location);
-	  }
-	| cast_expression
-	;
-
-cast_list
-	: parenthesized_expression_0 CLOSE_PARENS_CAST unary_expression
-	  {
-		$$ = new Cast ((Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| parenthesized_expression_0 CLOSE_PARENS_OPEN_PARENS cast_expression
-	  {
-		$$ = new Cast ((Expression) $1, (Expression) $3, lexer.Location);
-	  }	
-	;
-
-cast_expression
-	: cast_list
-	| OPEN_PARENS non_expression_type CLOSE_PARENS prefixed_unary_expression
-	  {
-		$$ = new Cast ((Expression) $2, (Expression) $4, lexer.Location);
-	  }
-	;
-
-	//
-	// The idea to split this out is from Rhys' grammar
-	// to solve the problem with casts.
-	//
-prefixed_unary_expression
-	: unary_expression
-	| PLUS prefixed_unary_expression
-	  { 
-	  	$$ = new Unary (Unary.Operator.UnaryPlus, (Expression) $2, lexer.Location);
-	  } 
-	| MINUS prefixed_unary_expression 
-	  { 
-		$$ = new Unary (Unary.Operator.UnaryNegation, (Expression) $2, lexer.Location);
-	  }
-	| OP_INC prefixed_unary_expression 
-	  {
-		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement,
-				       (Expression) $2, lexer.Location);
-	  }
-	| OP_DEC prefixed_unary_expression 
-	  {
-		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement,
-				       (Expression) $2, lexer.Location);
-	  }
-	| STAR prefixed_unary_expression
-	  {
-		$$ = new Unary (Unary.Operator.Indirection, (Expression) $2, lexer.Location);
-	  }
-	| BITWISE_AND prefixed_unary_expression
-	  {
-		$$ = new Unary (Unary.Operator.AddressOf, (Expression) $2, lexer.Location);
-	  }
-	;
-
-pre_increment_expression
-	: OP_INC prefixed_unary_expression 
-	  {
-		$$ = new UnaryMutator (UnaryMutator.Mode.PreIncrement,
-				       (Expression) $2, lexer.Location);
-	  }
-	;
-
-pre_decrement_expression
-	: OP_DEC prefixed_unary_expression 
-	  {
-		$$ = new UnaryMutator (UnaryMutator.Mode.PreDecrement,
-				       (Expression) $2, lexer.Location);
-	  }
-	;
-
-multiplicative_expression
-	: prefixed_unary_expression
-	| multiplicative_expression STAR prefixed_unary_expression
-	  {
-		$$ = new Binary (Binary.Operator.Multiply, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| multiplicative_expression DIV prefixed_unary_expression
-	  {
-		$$ = new Binary (Binary.Operator.Division, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| multiplicative_expression PERCENT prefixed_unary_expression 
-	  {
-		$$ = new Binary (Binary.Operator.Modulus, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-additive_expression
-	: multiplicative_expression
-	| additive_expression PLUS multiplicative_expression 
-	  {
-		$$ = new Binary (Binary.Operator.Addition, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| additive_expression MINUS multiplicative_expression
-	  {
-		$$ = new Binary (Binary.Operator.Subtraction, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-shift_expression
-	: additive_expression
-	| shift_expression OP_SHIFT_LEFT additive_expression
-	  {
-		$$ = new Binary (Binary.Operator.LeftShift, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| shift_expression OP_SHIFT_RIGHT additive_expression
-	  {
-		$$ = new Binary (Binary.Operator.RightShift, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	; 
-
-relational_expression
-	: shift_expression
-	| relational_expression OP_LT shift_expression
-	  {
-		$$ = new Binary (Binary.Operator.LessThan, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| relational_expression OP_GT shift_expression
-	  {
-		$$ = new Binary (Binary.Operator.GreaterThan, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| relational_expression OP_LE shift_expression
-	  {
-		$$ = new Binary (Binary.Operator.LessThanOrEqual, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| relational_expression OP_GE shift_expression
-	  {
-		$$ = new Binary (Binary.Operator.GreaterThanOrEqual, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| relational_expression IS type
-	  {
-		$$ = new Is ((Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| relational_expression AS type
-	  {
-		$$ = new As ((Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-equality_expression
-	: relational_expression
-	| equality_expression OP_EQ relational_expression
-	  {
-		$$ = new Binary (Binary.Operator.Equality, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| equality_expression OP_NE relational_expression
-	  {
-		$$ = new Binary (Binary.Operator.Inequality, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	; 
-
-and_expression
-	: equality_expression
-	| and_expression BITWISE_AND equality_expression
-	  {
-		$$ = new Binary (Binary.Operator.BitwiseAnd, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-exclusive_or_expression
-	: and_expression
-	| exclusive_or_expression CARRET and_expression
-	  {
-		$$ = new Binary (Binary.Operator.ExclusiveOr, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-inclusive_or_expression
-	: exclusive_or_expression
-	| inclusive_or_expression BITWISE_OR exclusive_or_expression
-	  {
-		$$ = new Binary (Binary.Operator.BitwiseOr, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-conditional_and_expression
-	: inclusive_or_expression
-	| conditional_and_expression OP_AND inclusive_or_expression
-	  {
-		$$ = new Binary (Binary.Operator.LogicalAnd, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-conditional_or_expression
-	: conditional_and_expression
-	| conditional_or_expression OP_OR conditional_and_expression
-	  {
-		$$ = new Binary (Binary.Operator.LogicalOr, 
-			         (Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	;
-
-conditional_expression
-	: conditional_or_expression
-	| conditional_or_expression INTERR expression COLON expression 
-	  {
-		$$ = new Conditional ((Expression) $1, (Expression) $3, (Expression) $5, lexer.Location);
-	  }
-	;
-
-assignment_expression
-	: prefixed_unary_expression ASSIGN expression
-	  {
-		$$ = new Assign ((Expression) $1, (Expression) $3, lexer.Location);
-	  }
-	| prefixed_unary_expression OP_MULT_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.Multiply, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_DIV_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.Division, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_MOD_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.Modulus, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_ADD_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.Addition, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_SUB_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.Subtraction, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_SHIFT_LEFT_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.LeftShift, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_SHIFT_RIGHT_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.RightShift, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_AND_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.BitwiseAnd, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_OR_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.BitwiseOr, (Expression) $1, (Expression) $3, l);
-	  }
-	| prefixed_unary_expression OP_XOR_ASSIGN expression
-	  {
-		Location l = lexer.Location;
-
-		$$ = new CompoundAssign (
-			Binary.Operator.ExclusiveOr, (Expression) $1, (Expression) $3, l);
-	  }
-	;
-
-expression
-	: conditional_expression
-	| assignment_expression
-	;
-
-constant_expression
-	: expression
-	;
-
-boolean_expression
-	: expression
-	;
-
-//
-// 10 classes
-//
-class_declaration
-	: opt_attributes
-	  opt_modifiers
-	  opt_partial
-	  CLASS member_name
-	  {
-		MemberName name = MakeName ((MemberName) $5);
-		bool partial = (bool) $3;
-		int mod_flags = (int) $2;
-
-		if (partial) {
-			ClassPart part = PartialContainer.CreatePart (
-				current_namespace, current_class, name, mod_flags,
-				(Attributes) $1, Kind.Class, lexer.Location);
-
-			current_container = part.PartialContainer;
-			current_class = part;
-		} else {
-			if ((mod_flags &amp; Modifiers.STATIC) != 0) {
-				current_class = new StaticClass (
-					current_namespace, current_class, name,
-					mod_flags, (Attributes) $1, lexer.Location);
-			} else {
-				current_class = new Class (
-					current_namespace, current_class, name,
-					mod_flags, (Attributes) $1, lexer.Location);
-			}
-
-			current_container.AddClassOrStruct (current_class);
-			current_container = current_class;
-			RootContext.Tree.RecordDecl (name, current_class);
-		}
-	  }
-	  opt_class_base
-	  {
-		if ($7 != null) {
-			if (current_class.Name == &quot;System.Object&quot;) {
-				Report.Error (537, current_class.Location,
-					      &quot;The class System.Object cannot have a base &quot; +
-					      &quot;class or implement an interface.&quot;);
-			}
-			current_class.Bases = (ArrayList) $7;
-		}
-
-		if (RootContext.Documentation != null) {
-			current_class.DocComment = Lexer.consume_doc_comment ();
-			Lexer.doc_state = XmlCommentState.Allowed;
-		}
-	  }
-	  class_body
-	  {
-		if (RootContext.Documentation != null)
-			Lexer.doc_state = XmlCommentState.Allowed;
-	  }
-	  opt_semicolon 
-	  {
-		$$ = pop_current_class ();
-	  }
-	;	
-
-opt_partial
-	: /* empty */
-	  { $$ = (bool) false; }
-	| PARTIAL
-	  { $$ = (bool) true; }
-	;
-
-opt_modifiers
-	: /* empty */		{ $$ = (int) 0; }
-	| modifiers
-	;
-
-modifiers
-	: modifier
-	| modifiers modifier
-	  { 
-		int m1 = (int) $1;
-		int m2 = (int) $2;
-
-		if ((m1 &amp; m2) != 0) {
-			Location l = lexer.Location;
-			Report.Error (1004, l, &quot;Duplicate modifier: `&quot; + Modifiers.Name (m2) + &quot;'&quot;);
-		}
-		$$ = (int) (m1 | m2);
-	  }
-        ;
-
-modifier
-	: NEW			{ $$ = Modifiers.NEW; }
-	| PUBLIC		{ $$ = Modifiers.PUBLIC; }
-	| PROTECTED		{ $$ = Modifiers.PROTECTED; }
-	| INTERNAL		{ $$ = Modifiers.INTERNAL; }
-	| PRIVATE		{ $$ = Modifiers.PRIVATE; }
-	| ABSTRACT		{ $$ = Modifiers.ABSTRACT; }
-	| SEALED		{ $$ = Modifiers.SEALED; }
-	| STATIC		{ $$ = Modifiers.STATIC; }
-	| READONLY		{ $$ = Modifiers.READONLY; }
-	| VIRTUAL		{ $$ = Modifiers.VIRTUAL; }
-	| OVERRIDE 		{ $$ = Modifiers.OVERRIDE; }
-	| EXTERN		{ $$ = Modifiers.EXTERN; }
-	| VOLATILE		{ $$ = Modifiers.VOLATILE; }
-	| UNSAFE		{ $$ = Modifiers.UNSAFE; }
-	;
-
-opt_class_base
-	: /* empty */		{ $$ = null; }
-	| class_base		{ $$ = $1;   }
-	;
-
-class_base
-	: COLON type_list { $$ = $2; }
-	;
-
-//
-// Statements (8.2)
-//
-
-//
-// A block is &quot;contained&quot; on the following places:
-//	method_body
-//	property_declaration as part of the accessor body (get/set)
-//      operator_declaration
-//	constructor_declaration
-//	destructor_declaration
-//	event_declaration as part of add_accessor_declaration or remove_accessor_declaration
-//      
-block
-	: OPEN_BRACE 
-	  {
-		if (current_block == null){
-			current_block = new ToplevelBlock ((ToplevelBlock) top_current_block, current_local_parameters, lexer.Location);
-			top_current_block = current_block;
-		} else {
-		current_block = new Block (current_block, lexer.Location, Location.Null);
-		}
-	  } 
-	  opt_statement_list CLOSE_BRACE 
-	  { 
-		while (current_block.Implicit)
-			current_block = current_block.Parent;
-		$$ = current_block;
-		current_block.SetEndLocation (lexer.Location);
-		current_block = current_block.Parent;
-		if (current_block == null)
-			top_current_block = null;
-	  }
-	;
-
-opt_statement_list
-	: /* empty */
-	| statement_list 
-	;
-
-statement_list
-	: statement
-	| statement_list statement
-	;
-
-statement
-	: declaration_statement
-	  {
-		if ($1 != null &amp;&amp; (Block) $1 != current_block){
-			current_block.AddStatement ((Statement) $1);
-			current_block = (Block) $1;
-		}
-	  }
-	| valid_declaration_statement
-	  {
-		current_block.AddStatement ((Statement) $1);
-	  }
-	| labeled_statement
-	;
-
-valid_declaration_statement
-	: block
-	| empty_statement
-        | expression_statement
-	| selection_statement
-	| iteration_statement
-	| jump_statement		  
-	| try_statement
-	| checked_statement
-	| unchecked_statement
-	| lock_statement
-	| using_statement
-	| unsafe_statement
-	| fixed_statement
-	;
-
-embedded_statement
-	: valid_declaration_statement
-	| declaration_statement
-	  {
-		  Report.Error (1023, lexer.Location, &quot;An embedded statement may not be a declaration.&quot;);
-		  $$ = null;
-	  }
-	| labeled_statement
-	  {
-		  Report.Error (1023, lexer.Location, &quot;An embedded statement may not be a labeled statement.&quot;);
-		  $$ = null;
-	  }
-	;
-
-empty_statement
-	: SEMICOLON
-	  {
-		  $$ = EmptyStatement.Value;
-	  }
-	;
-
-labeled_statement
-	: IDENTIFIER COLON 
-	  {
-		LabeledStatement labeled = new LabeledStatement ((string) $1, lexer.Location);
-
-		if (current_block.AddLabel ((string) $1, labeled, lexer.Location))
-			current_block.AddStatement (labeled);
-	  }
-	  statement
-	;
-
-declaration_statement
-	: local_variable_declaration SEMICOLON
-	  {
-		if ($1 != null){
-			DictionaryEntry de = (DictionaryEntry) $1;
-
-			$$ = declare_local_variables ((Expression) de.Key, (ArrayList) de.Value, lexer.Location);
-		}
-	  }
-
-	| local_constant_declaration SEMICOLON
-	  {
-		if ($1 != null){
-			DictionaryEntry de = (DictionaryEntry) $1;
-
-			$$ = declare_local_constants ((Expression) de.Key, (ArrayList) de.Value);
-		}
-	  }
-	;
-
-/* 
- * The following is from Rhys' grammar:
- * &gt; Types in local variable declarations must be recognized as 
- * &gt; expressions to prevent reduce/reduce errors in the grammar.
- * &gt; The expressions are converted into types during semantic analysis.
- */
-local_variable_type
-	: primary_expression opt_rank_specifier
-	  { 
-		// FIXME: Do something smart here regarding the composition of the type.
-
-		// Ok, the above &quot;primary_expression&quot; is there to get rid of
-		// both reduce/reduce and shift/reduces in the grammar, it should
-		// really just be &quot;type_name&quot;.  If you use type_name, a reduce/reduce
-		// creeps up.  If you use namespace_or_type_name (which is all we need
-		// really) two shift/reduces appear.
-		// 
-
-		// So the super-trick is that primary_expression
-		// can only be either a SimpleName or a MemberAccess. 
-		// The MemberAccess case arises when you have a fully qualified type-name like :
-		// Foo.Bar.Blah i;
-		// SimpleName is when you have
-		// Blah i;
-		  
-		Expression expr = (Expression) $1;  
-		if (!(expr is SimpleName || expr is MemberAccess || expr is ComposedCast)) {
-			Error_ExpectingTypeName (lexer.Location, expr);
-			$$ = null;
-		} else {
-			//
-			// So we extract the string corresponding to the SimpleName
-			// or MemberAccess
-			// 
-
-			if ((string) $2 == &quot;&quot;)
-				$$ = $1;
-			else
-				$$ = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
-		}
-	  }
-	| builtin_types opt_rank_specifier
-	  {
-		if ((string) $2 == &quot;&quot;)
-			$$ = $1;
-		else
-			$$ = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
-	  }
-        ;
-
-local_variable_pointer_type
-	: primary_expression STAR
-	  {
-		Expression expr = (Expression) $1;  
-		Location l = lexer.Location;
-
-		if (!(expr is SimpleName || expr is MemberAccess || expr is ComposedCast)) {
-			Error_ExpectingTypeName (l, expr);
-
-			$$ = null;
-		} else 
-			$$ = new ComposedCast ((Expression) $1, &quot;*&quot;, l);
-	  }
-        | builtin_types STAR
-	  {
-		$$ = new ComposedCast ((Expression) $1, &quot;*&quot;, lexer.Location);;
-	  }
-        | VOID STAR
-	  {
-		$$ = new ComposedCast (TypeManager.system_void_expr, &quot;*&quot;, lexer.Location);;
-	  }
-	| local_variable_pointer_type STAR
-          {
-		$$ = new ComposedCast ((Expression) $1, &quot;*&quot;, lexer.Location);
-	  }
-        ;
-
-local_variable_declaration
-	: local_variable_type variable_declarators
-	  {
-		if ($1 != null)
-			$$ = new DictionaryEntry ($1, $2);
-		else
-			$$ = null;
-	  }
-        | local_variable_pointer_type opt_rank_specifier variable_declarators
-	{
-		if ($1 != null){
-			Expression t;
-
-			if ((string) $2 == &quot;&quot;)
-				t = (Expression) $1;
-			else
-				t = new ComposedCast ((Expression) $1, (string) $2, lexer.Location);
-			$$ = new DictionaryEntry (t, $3);
-		} else 
-			$$ = null;
-	}
- 	;
-
-local_constant_declaration
-	: CONST local_variable_type constant_declarators
-	  {
-		if ($2 != null)
-			$$ = new DictionaryEntry ($2, $3);
-		else
-			$$ = null;
-	  }
-	;
-
-expression_statement
-	: statement_expression SEMICOLON
-	  {
-		$$ = $1;
-	  }
-	;
-
-	//
-	// We have to do the wrapping here and not in the case above,
-	// because statement_expression is used for example in for_statement
-	//
-statement_expression
-	: invocation_expression		{ $$ = new StatementExpression ((ExpressionStatement) $1, lexer.Location); }
-	| object_creation_expression	{ $$ = new StatementExpression ((ExpressionStatement) $1, lexer.Location); }
-	| assignment_expression		{ $$ = new StatementExpression ((ExpressionStatement) $1, lexer.Location); }
-	| post_increment_expression	{ $$ = new StatementExpression ((ExpressionStatement) $1, lexer.Location); }
-	| post_decrement_expression	{ $$ = new StatementExpression ((ExpressionStatement) $1, lexer.Location); }
-	| pre_increment_expression	{ $$ = new StatementExpression ((ExpressionStatement) $1, lexer.Location); }
-	| pre_decrement_expression	{ $$ = new StatementExpression ((ExpressionStatement) $1, lexer.Location); }
-	| error {
-		Report.Error (1002, lexer.Location, &quot;Expecting `;'&quot;);
-		$$ = null;
-	  }
-	;
-
-object_creation_expression
-	: object_or_delegate_creation_expression
-	  { note (&quot;complain if this is a delegate maybe?&quot;); } 
-	;
-
-selection_statement
-	: if_statement
-	| switch_statement
-	; 
-
-if_statement
-	: IF OPEN_PARENS _mark_ boolean_expression CLOSE_PARENS 
-	  embedded_statement
-	  { 
-		Location l = (Location) $3;
-
-		$$ = new If ((Expression) $4, (Statement) $6, l);
-
-		if (RootContext.WarningLevel &gt;= 4){
-			if ($6 == EmptyStatement.Value)
-				Report.Warning (642, lexer.Location, &quot;Possible mistaken empty statement&quot;);
-		}
-
-	  }
-	| IF OPEN_PARENS _mark_ boolean_expression CLOSE_PARENS
-	  embedded_statement ELSE embedded_statement
-	  {
-		Location l = (Location) $3;
-
-		$$ = new If ((Expression) $4, (Statement) $6, (Statement) $8, l);
-	  }
-	;
-
-switch_statement
-	: SWITCH OPEN_PARENS _mark_
-	  { 
-		switch_stack.Push (current_block);
-	  }
-	  expression CLOSE_PARENS 
-	  switch_block
-	  {
-		$$ = new Switch ((Expression) $5, (ArrayList) $7, (Location) $3);
-		current_block = (Block) switch_stack.Pop ();
-	  }
-	;
-
-switch_block
-	: OPEN_BRACE
-	  opt_switch_sections
-	  CLOSE_BRACE
-	  {
-		$$ = $2;
-	  }
-	;
-
-opt_switch_sections
-	: /* empty */ 		
-          {
-	  	Report.Error (1522, lexer.Location, &quot;Empty switch block&quot;); 
-	  }
-	| switch_sections
-	;
-
-switch_sections
-	: switch_section 
-	  {
-		ArrayList sections = new ArrayList (4);
-
-		sections.Add ($1);
-		$$ = sections;
-	  }
-	| switch_sections switch_section
-	  {
-		ArrayList sections = (ArrayList) $1;
-
-		sections.Add ($2);
-		$$ = sections;
-	  }
-	;
-
-switch_section
-	: switch_labels
-	  {
-		current_block = current_block.CreateSwitchBlock (lexer.Location);
-	  }
- 	  statement_list 
-	  {
-		Block topmost = current_block;
-
-		while (topmost.Implicit)
-			topmost = topmost.Parent;
-		$$ = new SwitchSection ((ArrayList) $1, topmost);
-	  }
-	;
-
-switch_labels
-	: switch_label 
-	  {
-		ArrayList labels = new ArrayList (4);
-
-		labels.Add ($1);
-		$$ = labels;
-	  }
-	| switch_labels switch_label 
-	  {
-		ArrayList labels = (ArrayList) ($1);
-		labels.Add ($2);
-
-		$$ = labels;
-	  }
-	;
-
-switch_label
-	: CASE constant_expression COLON 	{ $$ = new SwitchLabel ((Expression) $2, lexer.Location); }
-	| DEFAULT COLON				{ $$ = new SwitchLabel (null, lexer.Location); }
-	| error {
-		Report.Error (
-			1523, lexer.Location, 
-			&quot;The keyword case or default must precede code in switch block&quot;);
-	  }
-	;
-
-iteration_statement
-	: while_statement
-	| do_statement
-	| for_statement
-	| foreach_statement
-	;
-
-while_statement
-	: WHILE OPEN_PARENS _mark_ boolean_expression CLOSE_PARENS embedded_statement
-	{
-		Location l = (Location) $3;
-		$$ = new While ((Expression) $4, (Statement) $6, l);
-	
-		if (RootContext.WarningLevel &gt;= 4){
-			if ($6 == EmptyStatement.Value)
-				Report.Warning (642, lexer.Location, &quot;Possible mistaken empty statement&quot;);
-		}
-	}
-	;
-
-do_statement
-	: DO embedded_statement 
-	  WHILE OPEN_PARENS _mark_ boolean_expression CLOSE_PARENS SEMICOLON
-	  {
-		Location l = (Location) $5;
-
-		$$ = new Do ((Statement) $2, (Expression) $6, l);
-	  }
-	;
-
-for_statement
-	: FOR OPEN_PARENS 
-	  opt_for_initializer SEMICOLON _mark_
-	  {
-		Block assign_block = new Block (current_block);
-		current_block = assign_block;
-
-		if ($3 is DictionaryEntry){
-			DictionaryEntry de = (DictionaryEntry) $3;
-			
-			Expression type = (Expression) de.Key;
-			ArrayList var_declarators = (ArrayList) de.Value;
-
-			foreach (VariableDeclaration decl in var_declarators){
-
-				LocalInfo vi;
-
-				vi = current_block.AddVariable (type, decl.identifier, decl.Location);
-				if (vi == null)
-					continue;
-
-				Location l = lexer.Location;
-				Expression expr;
-				if (decl.expression_or_array_initializer is Expression){
-					expr = (Expression) decl.expression_or_array_initializer;
-				} else if (decl.expression_or_array_initializer == null) {
-					expr = null;
-				} else {
-					ArrayList init = (ArrayList) decl.expression_or_array_initializer;
-					expr = new ArrayCreation (type, &quot;&quot;, init, decl.Location);
-				}
-					
-				LocalVariableReference var;
-				var = new LocalVariableReference (assign_block, decl.identifier, l);
-
-				if (expr != null) {
-					Assign a = new Assign (var, expr, decl.Location);
-					
-					assign_block.AddStatement (new StatementExpression (a, lexer.Location));
-				}
-			}
-			
-			// Note: the $$ below refers to the value of this code block, not of the LHS non-terminal.
-			// This can be referred to as $6 below.
-			$$ = null;
-		} else {
-			$$ = $3;
-		}
-	  } 
-	  opt_for_condition SEMICOLON
-	  opt_for_iterator CLOSE_PARENS 
-	  embedded_statement
-	  {
-		Location l = (Location) $5;
-
-		For f = new For ((Statement) $6, (Expression) $7, (Statement) $9, (Statement) $11, l);
-
-		if (RootContext.WarningLevel &gt;= 4){
-			if ($11 == EmptyStatement.Value)
-				Report.Warning (642, lexer.Location, &quot;Possible mistaken empty statement&quot;);
-		}
-
-		current_block.AddStatement (f);
-		while (current_block.Implicit)
-			current_block = current_block.Parent;
-		$$ = current_block;
-		current_block = current_block.Parent;
-	  }
-	;
-
-opt_for_initializer
-	: /* empty */		{ $$ = EmptyStatement.Value; }
-	| for_initializer	
-	;
-
-for_initializer
-	: local_variable_declaration
-	| statement_expression_list
-	;
-
-opt_for_condition
-	: /* empty */		{ $$ = null; }
-	| boolean_expression
-	;
-
-opt_for_iterator
-	: /* empty */		{ $$ = EmptyStatement.Value; }
-	| for_iterator
-	;
-
-for_iterator
-	: statement_expression_list
-	;
-
-statement_expression_list
-	: statement_expression	
-	  {
-		// CHANGE: was `null'
-		Block b = new Block (current_block, Block.Flags.Implicit);   
-
-		b.AddStatement ((Statement) $1);
-		$$ = b;
-	  }
-	| statement_expression_list COMMA statement_expression
-	  {
-		Block b = (Block) $1;
-
-		b.AddStatement ((Statement) $3);
-		$$ = $1;
-	  }
-	;
-
-foreach_statement
-	: FOREACH OPEN_PARENS type IN expression CLOSE_PARENS
-	{
-		Report.Error (230, lexer.Location, &quot;Type and identifier are both required in a foreach statement&quot;);
-		$$ = null;
-	}
-	| FOREACH OPEN_PARENS type IDENTIFIER IN _mark_
-	  expression CLOSE_PARENS 
-	  {
-		Block foreach_block = new Block (current_block);
-		current_block = foreach_block;
-
-		Location l = lexer.Location;
-		LocalInfo vi;
-
-		vi = foreach_block.AddVariable ((Expression) $3, (string) $4, l);
-		if (vi != null) {
-			vi.ReadOnly = true;
-
-			// Get a writable reference to this read-only variable.
-			//
-			// Note that the $$ here refers to the value of _this_ code block,
-			// not the value of the LHS non-terminal.  This can be referred to as $9 below.
-			$$ = new LocalVariableReference (foreach_block, (string) $4, l, vi, false);
-		} else {
-			$$ = null;
-		}
-	  } 
-	  embedded_statement 
-	  {
-		LocalVariableReference v = (LocalVariableReference) $9;
-		Location l = (Location) $6;
-
-		if (v != null) {
-			Foreach f = new Foreach ((Expression) $3, v, (Expression) $7, (Statement) $10, l);
-			current_block.AddStatement (f);
-		}
-
-		while (current_block.Implicit)
-			  current_block = current_block.Parent;
-		$$ = current_block;
-		current_block = current_block.Parent;
-	  }
-	;
-
-jump_statement
-	: break_statement
-	| continue_statement
-	| goto_statement
-	| return_statement
-	| throw_statement
-	| yield_statement
-	;
-
-break_statement
-	: BREAK SEMICOLON
-	  {
-		$$ = new Break (lexer.Location);
-	  }
-	;
-
-continue_statement
-	: CONTINUE SEMICOLON
-	  {
-		$$ = new Continue (lexer.Location);
-	  }
-	;
-
-goto_statement
-	: GOTO IDENTIFIER SEMICOLON 
-	  {
-		$$ = new Goto ((string) $2, lexer.Location);
-	  }
-	| GOTO CASE constant_expression SEMICOLON
-	  {
-		$$ = new GotoCase ((Expression) $3, lexer.Location);
-	  }
-	| GOTO DEFAULT SEMICOLON 
-	  {
-		$$ = new GotoDefault (lexer.Location);
-	  }
-	; 
-
-return_statement
-	: RETURN opt_expression SEMICOLON
-	  {
-		$$ = new Return ((Expression) $2, lexer.Location);
-	  }
-	;
-
-throw_statement
-	: THROW opt_expression SEMICOLON
-	  {
-		$$ = new Throw ((Expression) $2, lexer.Location);
-	  }
-	;
-
-yield_statement 
-	: IDENTIFIER RETURN expression SEMICOLON
-	  {
-		string s = (string) $1;
-		if (s != &quot;yield&quot;){
-			Report.Error (1003, lexer.Location, &quot;; expected&quot;);
-			$$ = null;
-		}
-		if (RootContext.Version == LanguageVersion.ISO_1){
-			Report.FeatureIsNotStandardized (lexer.Location, &quot;yield statement&quot;);
-			$$ = null;
-		}
-		if (iterator_container == null){
-			Report.Error (204, lexer.Location, &quot;yield statement can only be used within a method, operator or property&quot;);
-			$$ = null;
-		} else {
-			iterator_container.SetYields ();
-			$$ = new Yield ((Expression) $3, lexer.Location); 
-		}
-	  }
-	| IDENTIFIER RETURN SEMICOLON
-	{
-		Report.Error (1627, lexer.Location, &quot;Expression expected after yield return&quot;);
-		$$ = null;
-	}
-	| IDENTIFIER BREAK SEMICOLON
-	  {
-		string s = (string) $1;
-		if (s != &quot;yield&quot;){
-			Report.Error (1003, lexer.Location, &quot;; expected&quot;);
-			$$ = null;
-		}
-		if (RootContext.Version == LanguageVersion.ISO_1){
-			Report.FeatureIsNotStandardized (lexer.Location, &quot;yield statement&quot;);
-			$$ = null;
-		}
-		if (iterator_container == null){
-			Report.Error (204, lexer.Location, &quot;yield statement can only be used within a method, operator or property&quot;);
-			$$ = null;
-		} else {
-			iterator_container.SetYields ();
-			$$ = new YieldBreak (lexer.Location);
-		}
-	  }
-	;
-
-opt_expression
-	: /* empty */
-	| expression
-	;
-
-try_statement
-	: TRY block catch_clauses 
-	{
-		Catch g = null;
-		
-		ArrayList c = (ArrayList)$3;
-		for (int i = 0; i &lt; c.Count; ++i) {
-			Catch cc = (Catch) c [i];
-			if (cc.IsGeneral) {
-				if (i != c.Count - 1)
-					Report.Error (1017, cc.loc, &quot;Empty catch block must be the last in a series of catch blocks&quot;);
-				g = cc;
-				c.RemoveAt (i);
-				i--;
-			}
-		}
-
-		// Now s contains the list of specific catch clauses
-		// and g contains the general one.
-		
-		$$ = new Try ((Block) $2, c, g, null, ((Block) $2).loc);
-	}
-	| TRY block opt_catch_clauses FINALLY block
-	  {
-		Catch g = null;
-		ArrayList s = new ArrayList (4);
-		ArrayList catch_list = (ArrayList) $3;
-
-		if (catch_list != null){
-			foreach (Catch cc in catch_list) {
-				if (cc.IsGeneral)
-					g = cc;
-				else
-					s.Add (cc);
-			}
-		}
-
-		$$ = new Try ((Block) $2, s, g, (Block) $5, ((Block) $2).loc);
-	  }
-	| TRY block error 
-	  {
-		Report.Error (1524, lexer.Location, &quot;Expected catch or finally&quot;);
-	  }
-	;
-
-opt_catch_clauses
-	: /* empty */  { $$ = null; }
-        | catch_clauses
-	;
-
-catch_clauses
-	: catch_clause 
-	  {
-		ArrayList l = new ArrayList (4);
-
-		l.Add ($1);
-		$$ = l;
-	  }
-	| catch_clauses catch_clause
-	  {
-		ArrayList l = (ArrayList) $1;
-
-		l.Add ($2);
-		$$ = l;
-	  }
-	;
-
-opt_identifier
-	: /* empty */	{ $$ = null; }
-	| IDENTIFIER
-	;
-
-catch_clause 
-	: CATCH opt_catch_args 
-	{
-		Expression type = null;
-		string id = null;
-		
-		if ($2 != null) {
-			DictionaryEntry cc = (DictionaryEntry) $2;
-			type = (Expression) cc.Key;
-			id   = (string) cc.Value;
-
-			if (id != null){
-				ArrayList one = new ArrayList (4);
-				Location loc = lexer.Location;
-
-				one.Add (new VariableDeclaration (id, null, loc));
-
-				current_block = new Block (current_block);
-				Block b = declare_local_variables (type, one, loc);
-				current_block = b;
-			}
-		}
-	} block {
-		Expression type = null;
-		string id = null;
-
-		if ($2 != null){
-			DictionaryEntry cc = (DictionaryEntry) $2;
-			type = (Expression) cc.Key;
-			id   = (string) cc.Value;
-
-			if (id != null){
-				while (current_block.Implicit)
-					current_block = current_block.Parent;
-				current_block = current_block.Parent;
-			}
-		}
-
-		$$ = new Catch (type, id, (Block) $4, ((Block) $4).loc);
-	}
-        ;
-
-opt_catch_args
-	: /* empty */ { $$ = null; }
-        | catch_args
-	;	  
-
-catch_args 
-        : OPEN_PARENS type opt_identifier CLOSE_PARENS 
-        {
-		$$ = new DictionaryEntry ($2, $3);
-	}
-        ;
-
-checked_statement
-	: CHECKED block
-	  {
-		$$ = new Checked ((Block) $2);
-	  }
-	;
-
-unchecked_statement
-	: UNCHECKED block
-	  {
-		$$ = new Unchecked ((Block) $2);
-	  }
-	;
-
-unsafe_statement
-	: UNSAFE 
-	{
-		if (!RootContext.Unsafe){
-			Report.Error (227, lexer.Location, 
-				&quot;Unsafe code can only be used if -unsafe is used&quot;);
-		}
-	} block {
-		$$ = new Unsafe ((Block) $3);
-	}
-	;
-
-fixed_statement
-	: FIXED OPEN_PARENS 
-	  type fixed_pointer_declarators 
-	  CLOSE_PARENS _mark_
-	  {
-		ArrayList list = (ArrayList) $4;
-		Expression type = (Expression) $3;
-		Location l = lexer.Location;
-		int top = list.Count;
-
-		Block assign_block = new Block (current_block);
-		current_block = assign_block;
-
-		for (int i = 0; i &lt; top; i++){
-			Pair p = (Pair) list [i];
-			LocalInfo v;
-
-			v = current_block.AddVariable (type, (string) p.First, l);
-			if (v == null)
-				continue;
-
-			v.ReadOnly = true;
-			v.Pinned = true;
-			p.First = v;
-			list [i] = p;
-		}
-	  }
-	  embedded_statement 
-	  {
-		Location l = (Location) $6;
-
-		Fixed f = new Fixed ((Expression) $3, (ArrayList) $4, (Statement) $8, l);
-
-		if (RootContext.WarningLevel &gt;= 4){
-			if ($8 == EmptyStatement.Value)
-				Report.Warning (642, lexer.Location, &quot;Possible mistaken empty statement&quot;);
-		}
-
-		current_block.AddStatement (f);
-		while (current_block.Implicit)
-			current_block = current_block.Parent;
-		$$ = current_block;
-		current_block = current_block.Parent;
-	  }
-	;
-
-fixed_pointer_declarators
-	: fixed_pointer_declarator	{ 
-	   	ArrayList declarators = new ArrayList (4);
-	   	if ($1 != null)
-			declarators.Add ($1);
-		$$ = declarators;
-	  }
-	| fixed_pointer_declarators COMMA fixed_pointer_declarator
-	  {
-		ArrayList declarators = (ArrayList) $1;
-		if ($3 != null)
-			declarators.Add ($3);
-		$$ = declarators;
-	  }
-	;
-
-fixed_pointer_declarator
-	: IDENTIFIER ASSIGN expression
-	  {	
-		$$ = new Pair ($1, $3);
-	  }
-	| IDENTIFIER
-	  {
-		Report.Error (210, lexer.Location, &quot;You must provide an initializer in a fixed or using statement declaration&quot;);
-		$$ = null;
-	  }
-	;
-
-lock_statement
-	: LOCK OPEN_PARENS expression CLOSE_PARENS 
-	  {
-		//
- 	  } 
-	  embedded_statement
-	  {
-		$$ = new Lock ((Expression) $3, (Statement) $6, lexer.Location);
-	  }
-	;
-
-using_statement
-	: USING OPEN_PARENS resource_acquisition CLOSE_PARENS _mark_
-	  {
-		Block assign_block = new Block (current_block);
-		current_block = assign_block;
-
-		if ($3 is DictionaryEntry){
-			DictionaryEntry de = (DictionaryEntry) $3;
-			Location l = lexer.Location;
-
-			Expression type = (Expression) de.Key;
-			ArrayList var_declarators = (ArrayList) de.Value;
-
-			ArrayList vars = new ArrayList (4);
-
-			foreach (VariableDeclaration decl in var_declarators){
-
-				LocalInfo vi = current_block.AddVariable (type, decl.identifier, decl.Location);
-				if (vi == null)
-					continue;
-				vi.ReadOnly = true;
-
-				Expression expr;
-				if (decl.expression_or_array_initializer is Expression){
-					expr = (Expression) decl.expression_or_array_initializer;
-				} else {
-					ArrayList init = (ArrayList) decl.expression_or_array_initializer;
-					if (init == null) {
-						Report.Error (210, l, &quot;You must provide an initializer in a fixed or using statement declaration&quot;);
-					}
-					
-					expr = new ArrayCreation (type, &quot;&quot;, init, decl.Location);
-				}
-
-				LocalVariableReference var;
-
-				// Get a writable reference to this read-only variable.
-				var = new LocalVariableReference (assign_block, decl.identifier, l, vi, false);
-
-				// This is so that it is not a warning on using variables
-				vi.Used = true;
-
-				vars.Add (new DictionaryEntry (var, expr));				
-
-				// Assign a = new Assign (var, expr, decl.Location);
-				// assign_block.AddStatement (new StatementExpression (a, lexer.Location));
-			}
-
-			// Note: the $$ here refers to the value of this code block and not of the LHS non-terminal.
-			// It can be referred to as $6 below.
-			$$ = new DictionaryEntry (type, vars);
-		 } else {
-			$$ = $3;
-		 }
-	  } 
-	  embedded_statement
-	  {
-		Using u = new Using ($6, (Statement) $7, (Location) $5);
-		current_block.AddStatement (u);
-		while (current_block.Implicit)
-			current_block = current_block.Parent;
-		$$ = current_block;
-		current_block = current_block.Parent;
-	  }
-	; 
-
-resource_acquisition
-	: local_variable_declaration
-	| expression
-	;
-
-// Utility rule to save location information
-_mark_
-	: /* empty */
-	{ $$ = lexer.Location; }
-
-%%
-
-// &lt;summary&gt;
-//   A class used to pass around variable declarations and constants
-// &lt;/summary&gt;
-public class VariableDeclaration {
-	public string identifier;
-	public object expression_or_array_initializer;
-	public Location Location;
-	public Attributes OptAttributes;
-	public string DocComment;
-
-	public VariableDeclaration (string id, object eoai, Location l, Attributes opt_attrs)
-	{
-		this.identifier = id;
-		this.expression_or_array_initializer = eoai;
-		this.Location = l;
-		this.OptAttributes = opt_attrs;
-	}
-
-	public VariableDeclaration (string id, object eoai, Location l) : this (id, eoai, l, null)
-	{
-	}
-}
-
-/// &lt;summary&gt;
-///  Used to pass around interface property information
-/// &lt;/summary&gt;
-public class InterfaceAccessorInfo {
-
-        public readonly Accessor Get, Set;
-
-        public InterfaceAccessorInfo (bool has_get, bool has_set,
-                                      Attributes get_attrs, Attributes set_attrs, int get_mod, int set_mod, Location get_loc, Location set_loc)
-        {
-		if (get_mod != 0)
-			Report.Error (275, get_loc, &quot;Accessibility modifiers can not be used on accessors in interfaces&quot;);
-		if (set_mod != 0)
-			Report.Error (275, set_loc, &quot;Accessibility modifiers can not be used on accessors in interfaces&quot;);
-			
-		if (has_get)
-			Get = new Accessor (null, 0, get_attrs, get_loc);
-		if (has_set)
-			Set = new Accessor (null, 0, set_attrs, set_loc);
-        }
-
-}
-
-
-// &lt;summary&gt;
-//   A class used to hold info about an indexer declarator
-// &lt;/summary&gt;
-public class IndexerDeclaration {
-	public Expression type;
-	public MemberName interface_type;
-	public Parameters param_list;
-
-	public IndexerDeclaration (Expression type, MemberName interface_type,
-				   Parameters param_list)
-	{
-		this.type = type;
-		this.interface_type = interface_type;
-		this.param_list = param_list;
-	}
-}
-
-//
-// We use this when we do not have an object in advance that is an IIteratorContainer
-//
-public class SimpleIteratorContainer : IIteratorContainer {
-	public bool Yields;
-
-	public static SimpleIteratorContainer Simple = new SimpleIteratorContainer ();
-
-	//
-	// Reset and return
-	//
-	public static SimpleIteratorContainer GetSimple () { 
-		Simple.Yields = false;
-		return Simple;
-	}
-
-	public void SetYields () { Yields = true; } 
-}
-
-// &lt;summary&gt;
-//  A class used to hold info about an operator declarator
-// &lt;/summary&gt;
-public class OperatorDeclaration {
-	public Operator.OpType optype;
-	public Expression ret_type, arg1type, arg2type;
-	public string arg1name, arg2name;
-	public Location location;
-
-	public OperatorDeclaration (Operator.OpType op, Expression ret_type, 
-				    Expression arg1type, string arg1name,
-				    Expression arg2type, string arg2name, Location location)
-	{
-		optype = op;
-		this.ret_type = ret_type;
-		this.arg1type = arg1type;
-		this.arg1name = arg1name;
-		this.arg2type = arg2type;
-		this.arg2name = arg2name;
-		this.location = location;
-	}
-
-}
-
-void Error_ExpectingTypeName (Location l, Expression expr)
-{
-	if (expr is Invocation){
-		Report.Error (1002, l, &quot;; expected&quot;);
-	} else {
-		Report.Error (-1, l, &quot;Invalid Type definition&quot;);
-	}
-}
-
-TypeContainer pop_current_class ()
-{
-	TypeContainer retval = current_class;
-
-	current_class = current_class.Parent;
-	current_container = current_container.Parent;
-	
-	if (current_class != current_container) {
-		if (!(current_class is ClassPart) ||
-		    ((ClassPart) current_class).PartialContainer != current_container)
-			throw new InternalErrorException ();
-	} else if (current_container is ClassPart)
-		current_container = ((ClassPart) current_class).PartialContainer;
-
-	return retval;
-}
-
-// &lt;summary&gt;
-//   Given the @class_name name, it creates a fully qualified name
-//   based on the containing declaration space
-// &lt;/summary&gt;
-MemberName
-MakeName (MemberName class_name)
-{
-	Namespace ns = current_namespace.NS;
-
-	if (current_container.Name == &quot;&quot;){
-		if (ns.Name != &quot;&quot;)
-			return new MemberName (ns.MemberName, class_name);
-		else
-			return class_name;
-	} else {
-		return new MemberName (current_container.MemberName, class_name);
-	}
-}
-
-Block declare_local_variables (Expression type, ArrayList variable_declarators, Location loc)
-{
-	Block implicit_block;
-	ArrayList inits = null;
-
-	//
-	// We use the `Used' property to check whether statements
-	// have been added to the current block.  If so, we need
-	// to create another block to contain the new declaration
-	// otherwise, as an optimization, we use the same block to
-	// add the declaration.
-	//
-	// FIXME: A further optimization is to check if the statements
-	// that were added were added as part of the initialization
-	// below.  In which case, no other statements have been executed
-	// and we might be able to reduce the number of blocks for
-	// situations like this:
-	//
-	// int j = 1;  int k = j + 1;
-	//
-	if (current_block.Used)
-		implicit_block = new Block (current_block, Block.Flags.Implicit, loc, Location.Null);
-	else
-		implicit_block = current_block;
-
-	foreach (VariableDeclaration decl in variable_declarators){
-
-		if (implicit_block.AddVariable (type, decl.identifier, decl.Location) != null) {
-			if (decl.expression_or_array_initializer != null){
-				if (inits == null)
-					inits = new ArrayList (4);
-				inits.Add (decl);
-			}
-		}
-	}
-
-	if (inits == null)
-		return implicit_block;
-
-	foreach (VariableDeclaration decl in inits){
-		Assign assign;
-		Expression expr;
-		
-		if (decl.expression_or_array_initializer is Expression){
-			expr = (Expression) decl.expression_or_array_initializer;
-
-		} else {
-			ArrayList init = (ArrayList) decl.expression_or_array_initializer;
-			
-			expr = new ArrayCreation (type, &quot;&quot;, init, decl.Location);
-		}
-
-		LocalVariableReference var;
-		var = new LocalVariableReference (implicit_block, decl.identifier, loc);
-
-		assign = new Assign (var, expr, decl.Location);
-
-		implicit_block.AddStatement (new StatementExpression (assign, lexer.Location));
-	}
-	
-	return implicit_block;
-}
-
-Block declare_local_constants (Expression type, ArrayList declarators)
-{
-	Block implicit_block;
-
-	if (current_block.Used)
-		implicit_block = new Block (current_block, Block.Flags.Implicit);
-	else
-		implicit_block = current_block;
-
-	foreach (VariableDeclaration decl in declarators){
-		implicit_block.AddConstant (type, decl.identifier, (Expression) decl.expression_or_array_initializer, decl.Location);
-	}
-	
-	return implicit_block;
-}
-
-void CheckAttributeTarget (string a)
-{
-	switch (a) {
-
-	case &quot;assembly&quot; : case &quot;module&quot; : case &quot;field&quot; : case &quot;method&quot; : case &quot;param&quot; : case &quot;property&quot; : case &quot;type&quot; :
-		return;
-		
-	default :
-		Location l = lexer.Location;
-		Report.Error (658, l, &quot;`&quot; + a + &quot;' is an invalid attribute target&quot;);
-		break;
-	}
-
-}
-
-void CheckUnaryOperator (Operator.OpType op)
-{
-	switch (op) {
-		
-	case Operator.OpType.LogicalNot: 
-	case Operator.OpType.OnesComplement: 
-	case Operator.OpType.Increment:
-	case Operator.OpType.Decrement:
-	case Operator.OpType.True: 
-	case Operator.OpType.False: 
-	case Operator.OpType.Addition: 
-	case Operator.OpType.Subtraction:
-		
-		break;
-		
-	default :
-		Location l = lexer.Location;
-		Report.Error (1019, l, &quot;Overloadable unary operator expected&quot;); 
-		break;
-		
-	}
-}
-
-void CheckBinaryOperator (Operator.OpType op)
-{
-	switch (op) {
-		
-	case Operator.OpType.Addition: 
-	case Operator.OpType.Subtraction: 
-	case Operator.OpType.Multiply:
-	case Operator.OpType.Division:
-	case Operator.OpType.Modulus: 
-	case Operator.OpType.BitwiseAnd: 
-	case Operator.OpType.BitwiseOr:
-	case Operator.OpType.ExclusiveOr: 
-	case Operator.OpType.LeftShift: 
-	case Operator.OpType.RightShift:
-	case Operator.OpType.Equality: 
-	case Operator.OpType.Inequality:
-	case Operator.OpType.GreaterThan: 
-	case Operator.OpType.LessThan: 
-	case Operator.OpType.GreaterThanOrEqual:
-	case Operator.OpType.LessThanOrEqual:
-		break;
-		
-	default :
-		Location l = lexer.Location;
-		Report.Error (1020, l, &quot;Overloadable binary operator expected&quot;);
-		break;
-	}
-	
-}
-
-void syntax_error (Location l, string msg)
-{
-	Report.Error (1003, l, &quot;Syntax error, &quot; + msg);
-}
-
-void note (string s)
-{
-	// Used to put annotations
-}
-
-Tokenizer lexer;
-
-public Tokenizer Lexer {
-	get {
-		return lexer;
-	}
-}		   
-
-public CSharpParser (SeekableStreamReader reader, SourceFile file, ArrayList defines)
-{
-	current_namespace = new NamespaceEntry (null, file, null, Location.Null);
-	this.name = file.Name;
-	this.file = file;
-	current_container = RootContext.Tree.Types;
-	// TODO: Make RootContext.Tree.Types a PartialContainer.
-	current_class = current_container;
-	current_container.NamespaceEntry = current_namespace;
-	oob_stack = new Stack ();
-	switch_stack = new Stack ();
-
-	lexer = new Tokenizer (reader, file, defines);
-}
-
-public void parse ()
-{
-	try {
-		if (yacc_verbose_flag &gt; 1)
-			yyparse (lexer, new yydebug.yyDebugSimple ());
-		else
-			yyparse (lexer);
-		Tokenizer tokenizer = lexer as Tokenizer;
-		tokenizer.cleanup ();
-	} catch (Exception e){
-		// 
-		// Removed for production use, use parser verbose to get the output.
-		//
-		// Console.WriteLine (e);
-		Report.Error (-25, lexer.Location, &quot;Parsing error&quot;);
-		if (yacc_verbose_flag &gt; 0)
-			Console.WriteLine (e);
-	}
-
-	RootContext.Tree.Types.NamespaceEntry = null;
-}
-
-void CheckToken (int error, int yyToken, string msg)
-{
-	if (yyToken &gt;= Token.FIRST_KEYWORD &amp;&amp; yyToken &lt;= Token.LAST_KEYWORD){
-		Report.Error (error, lexer.Location, String.Format (&quot;{0}: `{1}' is a keyword&quot;, msg, yyNames [yyToken].ToLower ()));
-		return;
-	}		
-	Report.Error (error, lexer.Location, msg);
-}
-
-void CheckIdentifierToken (int yyToken)
-{
-	CheckToken (1041, yyToken, &quot;Identifier expected&quot;);
-}
-
-string ConsumeStoredComment ()
-{
-	string s = tmpComment;
-	tmpComment = null;
-	Lexer.doc_state = XmlCommentState.Allowed;
-	return s;
-}
-
-/* end end end */
-}

Added: trunk/DotnetShell.Parser/dnsh.g
===================================================================
--- trunk/DotnetShell.Parser/dnsh.g	2005-06-01 20:36:58 UTC (rev 6)
+++ trunk/DotnetShell.Parser/dnsh.g	2005-06-01 20:37:07 UTC (rev 7)
@@ -0,0 +1,210 @@
+options
+{
+        language=&quot;CSharp&quot;;
+        namespace=&quot;NModule.Dependency.Parser&quot;;
+}
+
+class DnshParser extends Parser;
+
+options {
+        k=3;
+}
+
+tokens {
+	PROFILE=&quot;profile&quot;;
+	GLOBAL=&quot;global&quot;;
+	USING=&quot;using&quot;;
+	MODULE=&quot;module&quot;;
+	PREFIX=&quot;prefix&quot;;
+	IF=&quot;if&quot;;
+	ELSE=&quot;else&quot;;
+	RETURN=&quot;return&quot;;
+	OPTION=&quot;option&quot;;
+	ALIAS=&quot;alias&quot;;
+	SET=&quot;set&quot;;
+	GET=&quot;get&quot;;
+	EXTERNAL=&quot;external&quot;;
+	EXPORT=&quot;export&quot;;
+	SOURCE=&quot;source&quot;;
+}
+
+top_level:
+	profile_directive
+	| using_directive
+	| module_directive
+	| prefix_directive
+	| function_block
+	| option_block
+	| global_block
+	;
+
+profile_directive:
+	PROFILE STRING SC!;
+
+using_directive:
+	(global_metadata_directive)? USING NAMESPACE SC!;
+
+global_metadata_directive:
+	LBRACKET! GLOBAL RBRACKET!;
+
+module_directive:
+	MODULE NAMESPACE SC!;
+
+prefix_directive:
+	PREFIX ID SC!;
+
+function_block:
+	(metadata_declarations)*
+	ID arg_list
+	LBRACE!
+		internal_block
+	RBRACE!
+	;
+
+metadata_declarations:
+	LBRACKET! metadata_declaration (COMMA! metadata_declaration)* RBRACKET!
+	;
+
+metadata_declaration:
+	ID (ARG_LIST)?
+	;
+
+option_block:
+	OPTION LPAREN! STRING RPAREN!
+	LBRACE!
+	  (alias_declaration)*
+	RBRACE!
+	;
+
+alias_declaration:
+	ALIAS lvalue EQ rvalue SC!
+	;
+
+global_block:
+	GLOBAL (LPAREN STRING RPAREN)?
+	LBRACE!
+		internal_block
+	RBRACE!
+	;
+
+internal_block:
+	option_call
+	| expression
+	;
+
+option_call:
+	OPTION SET STRING STRING SC!
+ 	| OPTION GET STRING SC!
+	;
+
+expression:
+	assignment_expression
+	| if_expression
+	| shell_expression
+	| method_expression
+	| math_expression
+	;
+
+assignment_expression:
+	lvalue EQOP rvalue SC!
+	;
+
+if_expression:
+	IF LPAREN! if_conditionals RPAREN!
+	LBRACE!
+		internal_block
+	RBRACE!
+	(elseif_expression)*
+	(else_expression)?
+	;
+
+elseif_expression:
+	ELSE IF LPAREN! if_conditionals RPAREN!
+	LBRACE!
+		internal_block
+	RBRACE!
+	;
+
+else_expression:
+	ELSE
+	LBRACE!
+		internal_block
+	RBRACE!
+	;
+
+if_conditionals:
+	LPAREN! (if_conditional)* RPAREN!
+	;
+
+if_conditional:
+	cvalue COP cvalue
+	;
+
+cvalue:
+	VAR
+	| STRING
+	| method_expression
+	| LPAREN! if_conditional RPAREN!
+	;
+
+
+shell_expression:
+	source_expression
+	| export_expression
+	| external_expression
+	| external_call_expression
+	;
+
+source_expression:
+	SOURCE LPAREN! STRING RPAREN! SC!
+	;
+
+export_expression:
+	EXPORT LPAREN! STRING RPAREN! SC!
+	;
+
+external_expression:
+	LBRACKET! EXTERNAL RBRACKET! shell_assignment_expression
+	;
+
+external_call_expression:
+	AT ID arg_list SC!
+	;
+
+method_expression:
+	ID LPAREN! ARG_LIST RPAREN! SC!
+	;
+
+math_expression:
+	( math_value MOP math_value
+	| LPAREN math_expression RPAREN
+	)* SC!
+	;
+
+math_value:
+	ID
+	| NUM_TYPE
+	;
+
+shell_assignment_value:
+  assignment_expression
+	| lvalue EQ shell_expression;
+
+lvalue:
+	ID
+	| method_expression
+	;
+
+
+
+DnshLexer extends Lexer;
+
+COP:
+	(AND|OR|XOR|BAND|BOR|BXOR|NEQ|EQ|LS|LTE|GT|GTE|BSL|BSR)
+	;
+
+EQOP:
+	(ASSN|ASBSL|ASBSR|ASPL|ASMN|ASMUL|ASDIV|ASBA|ASBO|ASBX|ASBN)
+	;
+
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000002.html">[dnsh-commits] r6 - trunk
</A></li>
	<LI>Next message: <A HREF="000003.html">[dnsh-commits] r8 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#4">[ date ]</a>
              <a href="thread.html#4">[ thread ]</a>
              <a href="subject.html#4">[ subject ]</a>
              <a href="author.html#4">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/dnsh-commits">More information about the Dnsh-commits
mailing list</a><br>
</body></html>
